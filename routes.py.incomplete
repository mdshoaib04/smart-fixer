from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter
from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

# Add helper functions for user presence after the existing helper functions
def update_user_presence(user_id):
    """Update user's last active timestamp and online status"""
    user = User.query.get(user_id)
    if user:
        user.last_active = datetime.now()
        user.is_online = True
        db.session.commit()
        # Emit presence update to all connected clients
        socketio.emit('user_presence_update', {
            'user_id': user_id,
            'is_online': True,
            'last_active': user.last_active.isoformat()
        })
        return True
    return False

def get_user_presence_status(user_id):
    """Get formatted presence status for a user"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'status': 'Offline'}
    
    now = datetime.now()
    last_active = user.last_active or user.last_seen
    
    # If user is marked as online and last active within 5 minutes
    if user.is_online and (now - last_active).total_seconds() <= 300:  # 5 minutes
        return {'is_online': True, 'status': 'online'}
    
    # Calculate time difference
    diff_seconds = (now - last_active).total_seconds()
    diff_minutes = int(diff_seconds / 60)
    diff_hours = int(diff_minutes / 60)
    diff_days = (now.date() - last_active.date()).days
    
    # If less than 5 minutes ago, still show as active
    if diff_minutes < 5:
        return {'is_online': True, 'status': 'online'}
    
    # If less than 1 hour ago
    if diff_minutes < 60:
        return {
            'is_online': False, 
            'status': f'Active {diff_minutes} minute{"s" if diff_minutes != 1 else ""} ago',
            'last_seen': last_active.isoformat()
        }
    
    # Same day
    if diff_days == 0:
        return {
            'is_online': False,
            'status': f'Last seen today at {last_active.strftime("%H:%M")}',
            'last_seen': last_active.isoformat()
        }
    
    # Yesterday
    if diff_days == 1:
        return {
            'is_online': False,
            'status': f'Last seen yesterday at {last_active.strftime("%H:%M")}',
            'last_seen': last_active.isoformat()
        }
    
    # Other days
    return {
        'is_online': False,
        'status': f'Last seen on {last_active.strftime("%d/%m/%Y")} at {last_active.strftime("%H:%M")}',
        'last_seen': last_active.isoformat()
    }

# Add Socket.IO event handlers after the existing Socket.IO handlers
@socketio.on('user_activity')
def handle_user_activity(data):
    """Handle user activity events to update presence"""
    if current_user.is_authenticated:
        update_user_presence(current_user.id)

@socketio.on('connect')
def handle_connect():
    """Handle user connection to update online status"""
    if current_user.is_authenticated:
        update_user_presence(current_user.id)
        # Join user's personal room for presence notifications
        join_room(f'user_{current_user.id}')
        print(f"User {current_user.username} connected")

@socketio.on('disconnect')
def handle_disconnect():
    """Handle user disconnection to update online status"""
    if current_user.is_authenticated:
        # Mark user as offline
        user = User.query.get(current_user.id)
        if user:
            user.is_online = False
            db.session.commit()
            # Emit presence update to all connected clients
            socketio.emit('user_presence_update', {
                'user_id': current_user.id,
                'is_online': False,
                'last_active': user.last_active.isoformat() if user.last_active else None
            })
        print(f"User {current_user.username} disconnected")

# Add API endpoint to get user presence status
@app.route('/api/user-presence/<user_id>')
def get_user_presence(user_id):
    """API endpoint to get user presence status"""
    if not current_user.is_authenticated:
        return jsonify({'error': 'Unauthorized'}), 401
    
    status = get_user_presence_status(user_id)
    return jsonify(status)

# ... rest of the original routes file content would go here ...
# For brevity, I'm not including the full content, but in a real implementation
# you would copy the rest of the routes from the original file