from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter
from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/api/test-gemini', methods=['GET'])
@require_login
def api_test_gemini():
    # Updated to use the new abstraction
    from gemini_helper import test_gemini_connection
    result = test_gemini_connection()
    return jsonify({'result': result})

# Translation and Dictionary Routes
@app.route('/api/translate', methods=['POST'])
@require_login
def api_translate():
    data = request.json
    code = data.get('code', '')
    from_lang = data.get('from_lang', 'Unknown')
    to_lang = data.get('to_lang', 'Python')
    
    # Updated to use the new abstraction
    result = translate_code(code, from_lang, to_lang)
    return jsonify({'result': result})

@app.route('/api/dictionary', methods=['POST'])
@require_login
def api_dictionary():
    data = request.json
    language = data.get('language', 'Python')
    searchTerm = data.get('searchTerm', '')
    
    # Updated to use the new abstraction
    result = get_dictionary_content(language, searchTerm)
    return jsonify({'result': result})

@app.route('/api/code-history')
@require_login
def api_code_history():
    history = CodeHistory.query.filter_by(user_id=current_user.id).order_by(CodeHistory.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': h.id,
        'code': h.code,
        'language': h.language,
        'action': h.action,
        'result': h.result,
        'created_at': h.created_at.isoformat()
    } for h in history])

@app.route('/api/upload-profile-pic', methods=['POST'])
@require_login
def api_upload_profile_pic():
    try:
        if 'profile_pic' not in request.files:
            return jsonify({'error': 'No file selected'}), 400
        
        file = request.files['profile_pic']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if file and allowed_file(file.filename):
            # Ensure upload directory exists
            upload_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Generate unique filename
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            file_path = os.path.join(upload_dir, filename)
            
            # Save file
            file.save(file_path)
            
            # Update user profile
            current_user.profile_image_path = filename
            current_user.profile_image_url = f'/static/uploads/profiles/{filename}'
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'profile_image_url': current_user.profile_image_url
            })
        
        return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or GIF'}), 400
        
    except Exception as e:
        print(f"Profile upload error: {str(e)}")
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/api/update-profile', methods=['POST'])
@require_login
def api_update_profile():
    data = request.json
    username = data.get('username')
    bio = data.get('bio')
    location_enabled = data.get('location_enabled', False)
    
    # Update username if provided
    if username:
        # Check if username is already taken by another user
        existing_user = User.query.filter_by(username=username).first()
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'error': 'Username is already taken'}), 400
        current_user.username = username
    
    # Update bio if provided
    if bio is not None:
        current_user.bio = bio
    
    # Update location enabled setting
    current_user.location_enabled = location_enabled
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/posts', methods=['GET', 'POST'])
@require_login
def api_posts():
    if request.method == 'POST':
        data = request.json
        post = Post(
            user_id=current_user.id,
            code=data.get('code', ''),
            language=data.get('language', 'Unknown'),
            description=data.get('description', '')
        )
        db.session.add(post)
        db.session.commit()
        return jsonify({'success': True, 'post_id': post.id})
    
    posts = Post.query.order_by(Post.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments)
    } for p in posts])

@app.route('/api/posts/<int:post_id>/like', methods=['POST'])
@require_login
def api_like_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_like = PostLike.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_like:
        db.session.delete(existing_like)
        post.likes -= 1
    else:
        like = PostLike(post_id=post_id, user_id=current_user.id)
        db.session.add(like)
        post.likes += 1
        
        if post.user_id != current_user.id:
            # Create a more detailed notification with post preview
            post_preview = post.code[:50] + "..." if len(post.code) > 50 else post.code
            notif = Notification(
                user_id=post.user_id,
                type='like',
                content=f"{current_user.first_name} liked your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'likes': post.likes})

@app.route('/api/posts/<int:post_id>/comment', methods=['POST'])
@require_login
def api_add_comment(post_id):
    import re
    
    data = request.json
    comment_content = data.get('content', '')
    
    # Parse @username mentions and create notifications
    mentioned_usernames = re.findall(r'@(\w+)', comment_content)
    
    # Create the comment
    comment = Comment(
        post_id=post_id,
        user_id=current_user.id,
        content=comment_content
    )
    db.session.add(comment)
    
    post = Post.query.get(post_id)
    
    # Create notification for post owner (if not the commenter)
    if post and post.user_id != current_user.id:
        # Create a notification
        notif = Notification(
            user_id=post.user_id,
            type='comment',
            content=f"{current_user.first_name} commented on your post: '{comment_content}'",
            from_user_id=current_user.id
        )
        db.session.add(notif)
    
    # Create notifications for mentioned users
    for username in mentioned_usernames:
        mentioned_user = User.query.filter_by(username=username).first()
        if mentioned_user and mentioned_user.id != current_user.id and mentioned_user.id != post.user_id:
            notif = Notification(
                user_id=mentioned_user.id,
                type='mention',
                content=f"{current_user.first_name} mentioned you in a comment: '{comment_content}'",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/explore-posts')
@require_login
def api_explore_posts():
    from datetime import datetime, timedelta
    
    # Get friend IDs
    friend_ids = []
    friendships = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    for f in friendships:
        friend_id = f.friend_id if f.user_id == current_user.id else f.user_id
        friend_ids.append(friend_id)
    
    # Get posts from friends (most recent first)
    friend_posts = Post.query.filter(Post.user_id.in_(friend_ids)).order_by(Post.created_at.desc()).limit(25).all()
    
    # If we don't have enough friend posts, get posts from other users
    other_posts = []
    if len(friend_posts) < 25:
        # Get posts from other users (not friends and not self)
        other_posts = Post.query.filter(
            ~Post.user_id.in_(friend_ids + [current_user.id])
        ).order_by(Post.created_at.desc()).limit(25 - len(friend_posts)).all()
    
    # Combine posts
    all_posts = friend_posts + other_posts
    
    # Filter out any posts from users that don't exist in the system
    valid_posts = []
    for post in all_posts:
        # Verify the user exists in the system
        user = User.query.get(post.user_id)
        if user:
            valid_posts.append(post)
    
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'liked': bool(PostLike.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'saved': bool(PostSave.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments),
        'is_friend_post': p.user_id in friend_ids
    } for p in valid_posts])

@app.route('/api/share-post', methods=['POST'])
@require_login
def api_share_post():
    data = request.json
    post_id = data.get('post_id')
    friend_ids = data.get('friend_ids', [])
    
    post = Post.query.get_or_404(post_id)
    
    # Send notifications to selected friends
    for friend_id in friend_ids:
        friend = User.query.get(friend_id)
        if friend:
            notif = Notification(
                user_id=friend_id,
                type='share',
                content=f"{current_user.first_name} shared a post with you",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/friends')
@require_login
def api_friends():
    friends = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    friend_list = []
    for f in friends:
        friend_user = User.query.get(f.friend_id if f.user_id == current_user.id else f.user_id)
        if friend_user:
            friend_list.append({
                'id': friend_user.id,
                'name': f"{friend_user.first_name or ''} {friend_user.last_name or ''}".strip() or 'User',
                'image': friend_user.profile_image_url,
                'email': friend_user.email
            })
    
    return jsonify(friend_list)

@app.route('/api/friend-request', methods=['POST'])
@require_login
def api_friend_request():
    data = request.json
    friend_email = data.get('email', '')
    friend = User.query.filter_by(email=friend_email).first()
    
    if not friend:
        return jsonify({'error': 'User not found'}), 404
    
    if friend.id == current_user.id:
        return jsonify({'error': 'Cannot add yourself'}), 400
    
    existing = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == friend.id)) |
        ((Friendship.user_id == friend.id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing:
        return jsonify({'error': 'Request already exists'}), 400
    
    friendship = Friendship(user_id=current_user.id, friend_id=friend.id, status='pending')
    db.session.add(friendship)
    
    notif = Notification(
        user_id=friend.id,
        type='friend_request',
        content=f"{current_user.first_name} sent you a friend request",
        from_user_id=current_user.id
    )
    db.session.add(notif)
    db.session.commit()
    
    # Emit real-time notification
    from app import socketio
    socketio.emit('new_notification', {
        'user_id': friend.id,
        'notification': {
            'id': notif.id,
            'type': notif.type,
            'content': notif.content,
            'from_user': {
                'id': current_user.id,
                'name': f"{current_user.first_name or ''} {current_user.last_name or ''}".strip() or 'User',
                'image': current_user.profile_image_url
            },
            'read': notif.read,
            'created_at': notif.created_at.isoformat()
        }
    }, room=f'user_{friend.id}')
    
    return jsonify({'success': True})

@app.route('/api/user-status/<user_id>')
@require_login
def api_user_status(user_id):
    """Get user's online status and last seen time"""
    status = get_user_status(user_id)
    return jsonify(status)

@app.route('/api/posts/<int:post_id>/comments')
@require_login
def api_get_post_comments(post_id):
    from models import Comment
    comments = Comment.query.filter_by(post_id=post_id).order_by(Comment.created_at.desc()).all()
    
    return jsonify([{
        'id': c.id,
        'content': c.content,
        'author_name': f"{c.user.first_name or ''} {c.user.last_name or ''}".strip() or 'User',
        'user_image': c.user.profile_image_url,
        'created_at': c.created_at.isoformat()
    } for c in comments])

@app.route('/api/notifications')
@require_login
def api_notifications():
    notifs = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(50).all()
    
    return jsonify([{
        'id': n.id,
        'type': n.type,
        'content': n.content,
        'from_user': {
            'id': n.from_user.id,
            'name': f"{n.from_user.first_name or ''} {n.from_user.last_name or ''}".strip() or 'User',
            'image': n.from_user.profile_image_url
        } if n.from_user else None,
        'read': n.read,
        'created_at': n.created_at.isoformat()
    } for n in notifs])

@app.route('/api/notifications/unread-count')
@require_login
def api_unread_notifications_count():
    count = Notification.query.filter_by(user_id=current_user.id, read=False).count()
    return jsonify({'count': count})

@app.route('/api/notifications/mark-all-read', methods=['POST'])
@require_login
def api_mark_all_notifications_read():
    # Mark all unread notifications as read
    Notification.query.filter_by(user_id=current_user.id, read=False).update({'read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/notifications/<int:notif_id>/respond', methods=['POST'])
@require_login
def api_respond_notification(notif_id):
    notif = Notification.query.get_or_404(notif_id)
    data = request.json
    action = data.get('action')
    
    response_data = {'success': True}
    
    if notif.type == 'friend_request':
        # Get the friendship record for this request
        friendship = Friendship.query.filter(
            ((Friendship.user_id == notif.from_user_id) & (Friendship.friend_id == current_user.id))
        ).first()
        
        if friendship:
            if action == 'accept':
                # Accept the friend request - both users follow each other
                friendship.status = 'accepted'
                
                # Update notification content to show that user started following
                requester = User.query.get(notif.from_user_id)
                if requester:
                    notif.content = f"{requester.first_name} started following you"
                
                # Create notification for the requester that they are now following back
                requester_notif = Notification(
                    user_id=notif.from_user_id,
                    type='follow_back',
                    content=f"You and {current_user.first_name} now follow each other",
                    from_user_id=current_user.id
                )
                db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'follow_back':
                # Check if there's already a pending friendship in the reverse direction
                existing_reverse_friendship = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) & 
                    (Friendship.friend_id == notif.from_user_id)
                ).first()
                
                if existing_reverse_friendship:
                    # If there's already a request, accept it to make it mutual
                    existing_reverse_friendship.status = 'accepted'
                    
                    # Update notification content for both users
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You and {requester.first_name} now follow each other"
                        
                        # Create notification for the requester
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='follow_back',
                            content=f"You and {current_user.first_name} now follow each other",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                else:
                    # User follows requester back - create a NEW pending friendship request
                    reverse_friendship = Friendship(
                        user_id=current_user.id,
                        friend_id=notif.from_user_id,
                        status='pending'
                    )
                    db.session.add(reverse_friendship)
                    
                    # Update the existing notification to show that follow back request was sent
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You requested to follow {requester.first_name}"
                        
                        # Also create a notification for the requester that they have a follow request
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='friend_request',
                            content=f"{current_user.first_name} requested to follow you",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'deny':
                # Delete/deny the friend request
                db.session.delete(friendship)
                # Also delete the notification
                db.session.delete(notif)
    
    # Mark notification as read if it still exists
    if Notification.query.get(notif_id):
        notif.read = True
        
    db.session.commit()
    return jsonify(response_data)

@app.route('/api/time-spent')
@require_login
def api_time_spent():
    from datetime import date, timedelta
    
    # Get time data for the last 365 days
    time_data = TimeSpent.query.filter_by(user_id=current_user.id).order_by(TimeSpent.date.desc()).limit(365).all()
    
    # Get today's data specifically
    today = date.today()
    today_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    # Get yesterday's data specifically
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    
    return jsonify({
        'entries': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in time_data],
        'today_minutes': today_entry.minutes if today_entry else 0,
        'yesterday_minutes': yesterday_entry.minutes if yesterday_entry else 0
    })

@app.route('/api/track-time', methods=['POST'])
@require_login
def api_track_time():
    from datetime import date, datetime, timedelta
    
    # Get today's date
    today = date.today()
    
    # Check if there's already an entry for today
    time_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    if time_entry:
        # If entry exists, increment minutes by 1
        time_entry.minutes += 1
    else:
        # If no entry exists, create a new one
        time_entry = TimeSpent(
            user_id=current_user.id,
            date=today,
            minutes=1
        )
        db.session.add(time_entry)
    
    db.session.commit()
    
    # Get total time spent today for response
    total_today = time_entry.minutes
    
    # Get yesterday's time spent
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    yesterday_minutes = yesterday_entry.minutes if yesterday_entry else 0
    
    # Also return the last 30 days of data for real-time updates
    from datetime import date, timedelta
    thirty_days_ago = today - timedelta(days=29)
    recent_time_data = TimeSpent.query.filter(
        TimeSpent.user_id == current_user.id,
        TimeSpent.date >= thirty_days_ago
    ).order_by(TimeSpent.date.asc()).all()
    
    return jsonify({
        'success': True,
        'today_minutes': total_today,
        'yesterday_minutes': yesterday_minutes,
        'recent_data': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in recent_time_data],
        'message': f'Time tracked successfully. Today: {total_today} minutes, Yesterday: {yesterday_minutes} minutes'
    })

# SocketIO Events (commented out to avoid conflicts)
@socketio.on('join')
def on_join(data):
    room = data.get('room')
    join_room(room)
    emit('user_joined', {'user': current_user.first_name}, room=room)

@socketio.on('connect')
def on_connect():
    # Join user's personal room for notifications
    from flask_socketio import join_room
    join_room(f'user_{current_user.id}')
    
    # Update user's online status
    current_user.is_online = True
    current_user.last_seen = datetime.now()
    db.session.commit()
    
@socketio.on('disconnect')
def on_disconnect():
    # Leave user's personal room
    from flask_socketio import leave_room
    leave_room(f'user_{current_user.id}')
    
    # Update user's offline status
    current_user.is_online = False
    current_user.last_seen = datetime.now()
    db.session.commit()

def get_user_status(user_id):
    """Get user's online status and last seen time"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'last_seen': None}
    
    # If user is marked as online, they are definitely online
    if user.is_online:
        return {'is_online': True, 'last_seen': user.last_seen}
    
    # If user is marked as offline but was seen recently (within 5 minutes), show as recently active
    if user.last_seen and datetime.now() - user.last_seen < timedelta(minutes=5):
        return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': True}
    
    # Otherwise, show last seen time
    return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': False}

@socketio.on('leave')
def on_leave(data):
    room = data.get('room')
    leave_room(room)
    emit('user_left', {'user': current_user.first_name}, room=room)

@socketio.on('send_message')
def on_message(data):
    room = data.get('room')
    message_text = data.get('message')
    code_snippet = data.get('code_snippet')
    receiver_id = data.get('receiver_id')
    
    message = Message(
        sender_id=current_user.id,
        receiver_id=receiver_id if receiver_id else None,
        content=message_text,
        code_snippet=code_snippet
    )
    db.session.add(message)
    db.session.commit()
    
    emit('receive_message', {
        'sender': current_user.first_name,
        'sender_image': current_user.profile_image_url,
        'message': message_text,
        'code_snippet': code_snippet,
        'timestamp': message.created_at.isoformat()
    }, room=room)

@app.route('/api/messages/<user_id>')
@require_login
def api_get_messages(user_id):
    messages = Message.query.filter(
        ((Message.sender_id == current_user.id) & (Message.receiver_id == user_id)) |
        ((Message.sender_id == user_id) & (Message.receiver_id == current_user.id))
    ).order_by(Message.created_at.asc()).all()
    
    return jsonify([{
        'id': m.id,
        'sender_id': m.sender_id,
        'content': m.content,
        'code_snippet': m.code_snippet,
        'created_at': m.created_at.isoformat()
    } for m in messages])

# App Download Route
@app.route('/download-app')
def download_app():
    try:
        # First try to serve the Windows application ZIP
        import os
        file_path = os.path.abspath('SmartFixer-Windows-App.zip')
        if os.path.exists(file_path):
            directory = os.path.dirname(file_path)
            filename = os.path.basename(file_path)
            return send_from_directory(directory, filename, as_attachment=True)
        
        # If that doesn't exist, try the distribution folder
        dist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'SmartFixer-Distribution')
        exe_path = os.path.join(dist_path, 'SmartFixer-App.exe')
        if os.path.exists(exe_path):
            return send_from_directory(dist_path, 'SmartFixer-App.exe', as_attachment=True)
        
        # Fallback if file doesn't exist
        raise FileNotFoundError("Application file not found")
    except Exception as e:
        print(f"Error saving location display: {e}")
    except Exception as e:
        print(f"Error in download_app: {str(e)}")
        # Return a proper error response
        return "Application download not available", 404

# QR Code generation endpoint
@app.route('/qr-code')
def qr_code():
    try:
        # Import qrcode only when needed to avoid dependency issues
        import qrcode
        from io import BytesIO
        
        # Get the download URL
        download_url = request.args.get('url', request.url_root + 'download-app')
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(download_url)
        qr.make(fit=True)
        
        # Create image
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Save to BytesIO
        img_io = BytesIO()
        img.save(img_io, 'PNG')
        img_io.seek(0)
        
        return send_file(img_io, mimetype='image/png')
    except ImportError:
        # Handle the case where qrcode is not installed
        return "QR Code generation not available", 404



from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter
from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/api/test-gemini', methods=['GET'])
@require_login
def api_test_gemini():
    # Updated to use the new abstraction
    from gemini_helper import test_gemini_connection
    result = test_gemini_connection()
    return jsonify({'result': result})

# Translation and Dictionary Routes
@app.route('/api/translate', methods=['POST'])
@require_login
def api_translate():
    data = request.json
    code = data.get('code', '')
    from_lang = data.get('from_lang', 'Unknown')
    to_lang = data.get('to_lang', 'Python')
    
    # Updated to use the new abstraction
    result = translate_code(code, from_lang, to_lang)
    return jsonify({'result': result})

@app.route('/api/dictionary', methods=['POST'])
@require_login
def api_dictionary():
    data = request.json
    language = data.get('language', 'Python')
    searchTerm = data.get('searchTerm', '')
    
    # Updated to use the new abstraction
    result = get_dictionary_content(language, searchTerm)
    return jsonify({'result': result})

@app.route('/api/code-history')
@require_login
def api_code_history():
    history = CodeHistory.query.filter_by(user_id=current_user.id).order_by(CodeHistory.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': h.id,
        'code': h.code,
        'language': h.language,
        'action': h.action,
        'result': h.result,
        'created_at': h.created_at.isoformat()
    } for h in history])

@app.route('/api/upload-profile-pic', methods=['POST'])
@require_login
def api_upload_profile_pic():
    try:
        if 'profile_pic' not in request.files:
            return jsonify({'error': 'No file selected'}), 400
        
        file = request.files['profile_pic']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if file and allowed_file(file.filename):
            # Ensure upload directory exists
            upload_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Generate unique filename
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            file_path = os.path.join(upload_dir, filename)
            
            # Save file
            file.save(file_path)
            
            # Update user profile
            current_user.profile_image_path = filename
            current_user.profile_image_url = f'/static/uploads/profiles/{filename}'
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'profile_image_url': current_user.profile_image_url
            })
        
        return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or GIF'}), 400
        
    except Exception as e:
        print(f"Profile upload error: {str(e)}")
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/api/update-profile', methods=['POST'])
@require_login
def api_update_profile():
    data = request.json
    username = data.get('username')
    bio = data.get('bio')
    location_enabled = data.get('location_enabled', False)
    
    # Update username if provided
    if username:
        # Check if username is already taken by another user
        existing_user = User.query.filter_by(username=username).first()
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'error': 'Username is already taken'}), 400
        current_user.username = username
    
    # Update bio if provided
    if bio is not None:
        current_user.bio = bio
    
    # Update location enabled setting
    current_user.location_enabled = location_enabled
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/posts', methods=['GET', 'POST'])
@require_login
def api_posts():
    if request.method == 'POST':
        data = request.json
        post = Post(
            user_id=current_user.id,
            code=data.get('code', ''),
            language=data.get('language', 'Unknown'),
            description=data.get('description', '')
        )
        db.session.add(post)
        db.session.commit()
        return jsonify({'success': True, 'post_id': post.id})
    
    posts = Post.query.order_by(Post.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments)
    } for p in posts])

@app.route('/api/posts/<int:post_id>/like', methods=['POST'])
@require_login
def api_like_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_like = PostLike.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_like:
        db.session.delete(existing_like)
        post.likes -= 1
    else:
        like = PostLike(post_id=post_id, user_id=current_user.id)
        db.session.add(like)
        post.likes += 1
        
        if post.user_id != current_user.id:
            # Create a more detailed notification with post preview
            post_preview = post.code[:50] + "..." if len(post.code) > 50 else post.code
            notif = Notification(
                user_id=post.user_id,
                type='like',
                content=f"{current_user.first_name} liked your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'likes': post.likes})

@app.route('/api/posts/<int:post_id>/comment', methods=['POST'])
@require_login
def api_add_comment(post_id):
    import re
    
    data = request.json
    comment_content = data.get('content', '')
    
    # Parse @username mentions and create notifications
    mentioned_usernames = re.findall(r'@(\w+)', comment_content)
    
    # Create the comment
    comment = Comment(
        post_id=post_id,
        user_id=current_user.id,
        content=comment_content
    )
    db.session.add(comment)
    
    post = Post.query.get(post_id)
    
    # Create notification for post owner (if not the commenter)
    if post and post.user_id != current_user.id:
        # Create a notification
        notif = Notification(
            user_id=post.user_id,
            type='comment',
            content=f"{current_user.first_name} commented on your post: '{comment_content}'",
            from_user_id=current_user.id
        )
        db.session.add(notif)
    
    # Create notifications for mentioned users
    for username in mentioned_usernames:
        mentioned_user = User.query.filter_by(username=username).first()
        if mentioned_user and mentioned_user.id != current_user.id and mentioned_user.id != post.user_id:
            notif = Notification(
                user_id=mentioned_user.id,
                type='mention',
                content=f"{current_user.first_name} mentioned you in a comment: '{comment_content}'",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/explore-posts')
@require_login
def api_explore_posts():
    from datetime import datetime, timedelta
    
    # Get friend IDs
    friend_ids = []
    friendships = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    for f in friendships:
        friend_id = f.friend_id if f.user_id == current_user.id else f.user_id
        friend_ids.append(friend_id)
    
    # Get posts from friends (most recent first)
    friend_posts = Post.query.filter(Post.user_id.in_(friend_ids)).order_by(Post.created_at.desc()).limit(25).all()
    
    # If we don't have enough friend posts, get posts from other users
    other_posts = []
    if len(friend_posts) < 25:
        # Get posts from other users (not friends and not self)
        other_posts = Post.query.filter(
            ~Post.user_id.in_(friend_ids + [current_user.id])
        ).order_by(Post.created_at.desc()).limit(25 - len(friend_posts)).all()
    
    # Combine posts
    all_posts = friend_posts + other_posts
    
    # Filter out any posts from users that don't exist in the system
    valid_posts = []
    for post in all_posts:
        # Verify the user exists in the system
        user = User.query.get(post.user_id)
        if user:
            valid_posts.append(post)
    
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'liked': bool(PostLike.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'saved': bool(PostSave.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments),
        'is_friend_post': p.user_id in friend_ids
    } for p in valid_posts])

@app.route('/api/share-post', methods=['POST'])
@require_login
def api_share_post():
    data = request.json
    post_id = data.get('post_id')
    friend_ids = data.get('friend_ids', [])
    
    post = Post.query.get_or_404(post_id)
    
    # Send notifications to selected friends
    for friend_id in friend_ids:
        friend = User.query.get(friend_id)
        if friend:
            notif = Notification(
                user_id=friend_id,
                type='share',
                content=f"{current_user.first_name} shared a post with you",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/friends')
@require_login
def api_friends():
    friends = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    friend_list = []
    for f in friends:
        friend_user = User.query.get(f.friend_id if f.user_id == current_user.id else f.user_id)
        if friend_user:
            friend_list.append({
                'id': friend_user.id,
                'name': f"{friend_user.first_name or ''} {friend_user.last_name or ''}".strip() or 'User',
                'image': friend_user.profile_image_url,
                'email': friend_user.email
            })
    
    return jsonify(friend_list)

@app.route('/api/friend-request', methods=['POST'])
@require_login
def api_friend_request():
    data = request.json
    friend_email = data.get('email', '')
    friend = User.query.filter_by(email=friend_email).first()
    
    if not friend:
        return jsonify({'error': 'User not found'}), 404
    
    if friend.id == current_user.id:
        return jsonify({'error': 'Cannot add yourself'}), 400
    
    existing = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == friend.id)) |
        ((Friendship.user_id == friend.id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing:
        return jsonify({'error': 'Request already exists'}), 400
    
    friendship = Friendship(user_id=current_user.id, friend_id=friend.id, status='pending')
    db.session.add(friendship)
    
    notif = Notification(
        user_id=friend.id,
        type='friend_request',
        content=f"{current_user.first_name} sent you a friend request",
        from_user_id=current_user.id
    )
    db.session.add(notif)
    db.session.commit()
    
    # Emit real-time notification
    from app import socketio
    socketio.emit('new_notification', {
        'user_id': friend.id,
        'notification': {
            'id': notif.id,
            'type': notif.type,
            'content': notif.content,
            'from_user': {
                'id': current_user.id,
                'name': f"{current_user.first_name or ''} {current_user.last_name or ''}".strip() or 'User',
                'image': current_user.profile_image_url
            },
            'read': notif.read,
            'created_at': notif.created_at.isoformat()
        }
    }, room=f'user_{friend.id}')
    
    return jsonify({'success': True})

@app.route('/api/user-status/<user_id>')
@require_login
def api_user_status(user_id):
    """Get user's online status and last seen time"""
    status = get_user_status(user_id)
    return jsonify(status)

@app.route('/api/posts/<int:post_id>/comments')
@require_login
def api_get_post_comments(post_id):
    from models import Comment
    comments = Comment.query.filter_by(post_id=post_id).order_by(Comment.created_at.desc()).all()
    
    return jsonify([{
        'id': c.id,
        'content': c.content,
        'author_name': f"{c.user.first_name or ''} {c.user.last_name or ''}".strip() or 'User',
        'user_image': c.user.profile_image_url,
        'created_at': c.created_at.isoformat()
    } for c in comments])

@app.route('/api/notifications')
@require_login
def api_notifications():
    notifs = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(50).all()
    
    return jsonify([{
        'id': n.id,
        'type': n.type,
        'content': n.content,
        'from_user': {
            'id': n.from_user.id,
            'name': f"{n.from_user.first_name or ''} {n.from_user.last_name or ''}".strip() or 'User',
            'image': n.from_user.profile_image_url
        } if n.from_user else None,
        'read': n.read,
        'created_at': n.created_at.isoformat()
    } for n in notifs])

@app.route('/api/notifications/unread-count')
@require_login
def api_unread_notifications_count():
    count = Notification.query.filter_by(user_id=current_user.id, read=False).count()
    return jsonify({'count': count})

@app.route('/api/notifications/mark-all-read', methods=['POST'])
@require_login
def api_mark_all_notifications_read():
    # Mark all unread notifications as read
    Notification.query.filter_by(user_id=current_user.id, read=False).update({'read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/notifications/<int:notif_id>/respond', methods=['POST'])
@require_login
def api_respond_notification(notif_id):
    notif = Notification.query.get_or_404(notif_id)
    data = request.json
    action = data.get('action')
    
    response_data = {'success': True}
    
    if notif.type == 'friend_request':
        # Get the friendship record for this request
        friendship = Friendship.query.filter(
            ((Friendship.user_id == notif.from_user_id) & (Friendship.friend_id == current_user.id))
        ).first()
        
        if friendship:
            if action == 'accept':
                # Accept the friend request - both users follow each other
                friendship.status = 'accepted'
                
                # Update notification content to show that user started following
                requester = User.query.get(notif.from_user_id)
                if requester:
                    notif.content = f"{requester.first_name} started following you"
                
                # Create notification for the requester that they are now following back
                requester_notif = Notification(
                    user_id=notif.from_user_id,
                    type='follow_back',
                    content=f"You and {current_user.first_name} now follow each other",
                    from_user_id=current_user.id
                )
                db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'follow_back':
                # Check if there's already a pending friendship in the reverse direction
                existing_reverse_friendship = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) & 
                    (Friendship.friend_id == notif.from_user_id)
                ).first()
                
                if existing_reverse_friendship:
                    # If there's already a request, accept it to make it mutual
                    existing_reverse_friendship.status = 'accepted'
                    
                    # Update notification content for both users
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You and {requester.first_name} now follow each other"
                        
                        # Create notification for the requester
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='follow_back',
                            content=f"You and {current_user.first_name} now follow each other",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                else:
                    # User follows requester back - create a NEW pending friendship request
                    reverse_friendship = Friendship(
                        user_id=current_user.id,
                        friend_id=notif.from_user_id,
                        status='pending'
                    )
                    db.session.add(reverse_friendship)
                    
                    # Update the existing notification to show that follow back request was sent
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You requested to follow {requester.first_name}"
                        
                        # Also create a notification for the requester that they have a follow request
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='friend_request',
                            content=f"{current_user.first_name} requested to follow you",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'deny':
                # Delete/deny the friend request
                db.session.delete(friendship)
                # Also delete the notification
                db.session.delete(notif)
    
    # Mark notification as read if it still exists
    if Notification.query.get(notif_id):
        notif.read = True
        
    db.session.commit()
    return jsonify(response_data)

@app.route('/api/time-spent')
@require_login
def api_time_spent():
    from datetime import date, timedelta
    
    # Get time data for the last 365 days
    time_data = TimeSpent.query.filter_by(user_id=current_user.id).order_by(TimeSpent.date.desc()).limit(365).all()
    
    # Get today's data specifically
    today = date.today()
    today_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    # Get yesterday's data specifically
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    
    return jsonify({
        'entries': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in time_data],
        'today_minutes': today_entry.minutes if today_entry else 0,
        'yesterday_minutes': yesterday_entry.minutes if yesterday_entry else 0
    })

@app.route('/api/track-time', methods=['POST'])
@require_login
def api_track_time():
    from datetime import date, datetime, timedelta
    
    # Get today's date
    today = date.today()
    
    # Check if there's already an entry for today
    time_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    if time_entry:
        # If entry exists, increment minutes by 1
        time_entry.minutes += 1
    else:
        # If no entry exists, create a new one
        time_entry = TimeSpent(
            user_id=current_user.id,
            date=today,
            minutes=1
        )
        db.session.add(time_entry)
    
    db.session.commit()
    
    # Get total time spent today for response
    total_today = time_entry.minutes
    
    # Get yesterday's time spent
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    yesterday_minutes = yesterday_entry.minutes if yesterday_entry else 0
    
    # Also return the last 30 days of data for real-time updates
    from datetime import date, timedelta
    thirty_days_ago = today - timedelta(days=29)
    recent_time_data = TimeSpent.query.filter(
        TimeSpent.user_id == current_user.id,
        TimeSpent.date >= thirty_days_ago
    ).order_by(TimeSpent.date.asc()).all()
    
    return jsonify({
        'success': True,
        'today_minutes': total_today,
        'yesterday_minutes': yesterday_minutes,
        'recent_data': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in recent_time_data],
        'message': f'Time tracked successfully. Today: {total_today} minutes, Yesterday: {yesterday_minutes} minutes'
    })

# SocketIO Events (commented out to avoid conflicts)
@socketio.on('join')
def on_join(data):
    room = data.get('room')
    join_room(room)
    emit('user_joined', {'user': current_user.first_name}, room=room)

@socketio.on('connect')
def on_connect():
    # Join user's personal room for notifications
    from flask_socketio import join_room
    join_room(f'user_{current_user.id}')
    
    # Update user's online status
    current_user.is_online = True
    current_user.last_seen = datetime.now()
    db.session.commit()
    
@socketio.on('disconnect')
def on_disconnect():
    # Leave user's personal room
    from flask_socketio import leave_room
    leave_room(f'user_{current_user.id}')
    
    # Update user's offline status
    current_user.is_online = False
    current_user.last_seen = datetime.now()
    db.session.commit()

def get_user_status(user_id):
    """Get user's online status and last seen time"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'last_seen': None}
    
    # If user is marked as online, they are definitely online
    if user.is_online:
        return {'is_online': True, 'last_seen': user.last_seen}
    
    # If user is marked as offline but was seen recently (within 5 minutes), show as recently active
    if user.last_seen and datetime.now() - user.last_seen < timedelta(minutes=5):
        return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': True}
    
    # Otherwise, show last seen time
    return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': False}

@socketio.on('leave')
def on_leave(data):
    room = data.get('room')
    leave_room(room)
    emit('user_left', {'user': current_user.first_name}, room=room)

@socketio.on('send_message')
def on_message(data):
    room = data.get('room')
    message_text = data.get('message')
    code_snippet = data.get('code_snippet')
    receiver_id = data.get('receiver_id')
    
    message = Message(
        sender_id=current_user.id,
        receiver_id=receiver_id if receiver_id else None,
        content=message_text,
        code_snippet=code_snippet
    )
    db.session.add(message)
    db.session.commit()
    
    emit('receive_message', {
        'sender': current_user.first_name,
        'sender_image': current_user.profile_image_url,
        'message': message_text,
        'code_snippet': code_snippet,
        'timestamp': message.created_at.isoformat()
    }, room=room)

@app.route('/api/messages/<user_id>')
@require_login
def api_get_messages(user_id):
    messages = Message.query.filter(
        ((Message.sender_id == current_user.id) & (Message.receiver_id == user_id)) |
        ((Message.sender_id == user_id) & (Message.receiver_id == current_user.id))
    ).order_by(Message.created_at.asc()).all()
    
    return jsonify([{
        'id': m.id,
        'sender_id': m.sender_id,
        'content': m.content,
        'code_snippet': m.code_snippet,
        'created_at': m.created_at.isoformat()
    } for m in messages])

# App Download Route
@app.route('/download-app')
def download_app():
    try:
        # First try to serve the Windows application ZIP
        import os
        file_path = os.path.abspath('SmartFixer-Windows-App.zip')
        if os.path.exists(file_path):
            directory = os.path.dirname(file_path)
            filename = os.path.basename(file_path)
            return send_from_directory(directory, filename, as_attachment=True)
        
        # If that doesn't exist, try the distribution folder
        dist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'SmartFixer-Distribution')
        exe_path = os.path.join(dist_path, 'SmartFixer-App.exe')
        if os.path.exists(exe_path):
            return send_from_directory(dist_path, 'SmartFixer-App.exe', as_attachment=True)
        
        # Fallback if file doesn't exist
        raise FileNotFoundError("Application file not found")
    except Exception as e:
        print(f"Error in download_app: {str(e)}")
        # Return a proper error response
        return "Application download not available", 404

# QR Code generation endpoint
@app.route('/qr-code')
def qr_code():
    try:
        # Import qrcode only when needed to avoid dependency issues
        import qrcode
        from io import BytesIO
        
        # Get the download URL
        download_url = request.args.get('url', request.url_root + 'download-app')
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(download_url)
        qr.make(fit=True)
        
        # Create image
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Save to BytesIO
        img_io = BytesIO()
        img.save(img_io, 'PNG')
        img_io.seek(0)
        
        return send_file(img_io, mimetype='image/png')
    except ImportError:
        # Handle the case where qrcode is not installed
        return "QR Code generation not available", 404



from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter
from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/api/test-gemini', methods=['GET'])
@require_login
def api_test_gemini():
    # Updated to use the new abstraction
    from gemini_helper import test_gemini_connection
    result = test_gemini_connection()
    return jsonify({'result': result})

# Translation and Dictionary Routes
@app.route('/api/translate', methods=['POST'])
@require_login
def api_translate():
    data = request.json
    code = data.get('code', '')
    from_lang = data.get('from_lang', 'Unknown')
    to_lang = data.get('to_lang', 'Python')
    
    # Updated to use the new abstraction
    result = translate_code(code, from_lang, to_lang)
    return jsonify({'result': result})

@app.route('/api/dictionary', methods=['POST'])
@require_login
def api_dictionary():
    data = request.json
    language = data.get('language', 'Python')
    searchTerm = data.get('searchTerm', '')
    
    # Updated to use the new abstraction
    result = get_dictionary_content(language, searchTerm)
    return jsonify({'result': result})

@app.route('/api/code-history')
@require_login
def api_code_history():
    history = CodeHistory.query.filter_by(user_id=current_user.id).order_by(CodeHistory.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': h.id,
        'code': h.code,
        'language': h.language,
        'action': h.action,
        'result': h.result,
        'created_at': h.created_at.isoformat()
    } for h in history])

@app.route('/api/upload-profile-pic', methods=['POST'])
@require_login
def api_upload_profile_pic():
    try:
        if 'profile_pic' not in request.files:
            return jsonify({'error': 'No file selected'}), 400
        
        file = request.files['profile_pic']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if file and allowed_file(file.filename):
            # Ensure upload directory exists
            upload_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Generate unique filename
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            file_path = os.path.join(upload_dir, filename)
            
            # Save file
            file.save(file_path)
            
            # Update user profile
            current_user.profile_image_path = filename
            current_user.profile_image_url = f'/static/uploads/profiles/{filename}'
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'profile_image_url': current_user.profile_image_url
            })
        
        return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or GIF'}), 400
        
    except Exception as e:
        print(f"Profile upload error: {str(e)}")
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/api/update-profile', methods=['POST'])
@require_login
def api_update_profile():
    data = request.json
    username = data.get('username')
    bio = data.get('bio')
    location_enabled = data.get('location_enabled', False)
    
    # Update username if provided
    if username:
        # Check if username is already taken by another user
        existing_user = User.query.filter_by(username=username).first()
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'error': 'Username is already taken'}), 400
        current_user.username = username
    
    # Update bio if provided
    if bio is not None:
        current_user.bio = bio
    
    # Update location enabled setting
    current_user.location_enabled = location_enabled
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/posts', methods=['GET', 'POST'])
@require_login
def api_posts():
    if request.method == 'POST':
        data = request.json
        post = Post(
            user_id=current_user.id,
            code=data.get('code', ''),
            language=data.get('language', 'Unknown'),
            description=data.get('description', '')
        )
        db.session.add(post)
        db.session.commit()
        return jsonify({'success': True, 'post_id': post.id})
    
    posts = Post.query.order_by(Post.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments)
    } for p in posts])

@app.route('/api/posts/<int:post_id>/like', methods=['POST'])
@require_login
def api_like_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_like = PostLike.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_like:
        db.session.delete(existing_like)
        post.likes -= 1
    else:
        like = PostLike(post_id=post_id, user_id=current_user.id)
        db.session.add(like)
        post.likes += 1
        
        if post.user_id != current_user.id:
            # Create a more detailed notification with post preview
            post_preview = post.code[:50] + "..." if len(post.code) > 50 else post.code
            notif = Notification(
                user_id=post.user_id,
                type='like',
                content=f"{current_user.first_name} liked your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'likes': post.likes})

@app.route('/api/posts/<int:post_id>/comment', methods=['POST'])
@require_login
def api_add_comment(post_id):
    import re
    
    data = request.json
    comment_content = data.get('content', '')
    
    # Parse @username mentions and create notifications
    mentioned_usernames = re.findall(r'@(\w+)', comment_content)
    
    # Create the comment
    comment = Comment(
        post_id=post_id,
        user_id=current_user.id,
        content=comment_content
    )
    db.session.add(comment)
    
    post = Post.query.get(post_id)
    
    # Create notification for post owner (if not the commenter)
    if post and post.user_id != current_user.id:
        # Create a notification
        notif = Notification(
            user_id=post.user_id,
            type='comment',
            content=f"{current_user.first_name} commented on your post: '{comment_content}'",
            from_user_id=current_user.id
        )
        db.session.add(notif)
    
    # Create notifications for mentioned users
    for username in mentioned_usernames:
        mentioned_user = User.query.filter_by(username=username).first()
        if mentioned_user and mentioned_user.id != current_user.id and mentioned_user.id != post.user_id:
            notif = Notification(
                user_id=mentioned_user.id,
                type='mention',
                content=f"{current_user.first_name} mentioned you in a comment: '{comment_content}'",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/explore-posts')
@require_login
def api_explore_posts():
    from datetime import datetime, timedelta
    
    # Get friend IDs
    friend_ids = []
    friendships = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    for f in friendships:
        friend_id = f.friend_id if f.user_id == current_user.id else f.user_id
        friend_ids.append(friend_id)
    
    # Get posts from friends (most recent first)
    friend_posts = Post.query.filter(Post.user_id.in_(friend_ids)).order_by(Post.created_at.desc()).limit(25).all()
    
    # If we don't have enough friend posts, get posts from other users
    other_posts = []
    if len(friend_posts) < 25:
        # Get posts from other users (not friends and not self)
        other_posts = Post.query.filter(
            ~Post.user_id.in_(friend_ids + [current_user.id])
        ).order_by(Post.created_at.desc()).limit(25 - len(friend_posts)).all()
    
    # Combine posts
    all_posts = friend_posts + other_posts
    
    # Filter out any posts from users that don't exist in the system
    valid_posts = []
    for post in all_posts:
        # Verify the user exists in the system
        user = User.query.get(post.user_id)
        if user:
            valid_posts.append(post)
    
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'liked': bool(PostLike.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'saved': bool(PostSave.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments),
        'is_friend_post': p.user_id in friend_ids
    } for p in valid_posts])

@app.route('/api/share-post', methods=['POST'])
@require_login
def api_share_post():
    data = request.json
    post_id = data.get('post_id')
    friend_ids = data.get('friend_ids', [])
    
    post = Post.query.get_or_404(post_id)
    
    # Send notifications to selected friends
    for friend_id in friend_ids:
        friend = User.query.get(friend_id)
        if friend:
            notif = Notification(
                user_id=friend_id,
                type='share',
                content=f"{current_user.first_name} shared a post with you",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/friends')
@require_login
def api_friends():
    friends = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    friend_list = []
    for f in friends:
        friend_user = User.query.get(f.friend_id if f.user_id == current_user.id else f.user_id)
        if friend_user:
            friend_list.append({
                'id': friend_user.id,
                'name': f"{friend_user.first_name or ''} {friend_user.last_name or ''}".strip() or 'User',
                'image': friend_user.profile_image_url,
                'email': friend_user.email
            })
    
    return jsonify(friend_list)

@app.route('/api/friend-request', methods=['POST'])
@require_login
def api_friend_request():
    data = request.json
    friend_email = data.get('email', '')
    friend = User.query.filter_by(email=friend_email).first()
    
    if not friend:
        return jsonify({'error': 'User not found'}), 404
    
    if friend.id == current_user.id:
        return jsonify({'error': 'Cannot add yourself'}), 400
    
    existing = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == friend.id)) |
        ((Friendship.user_id == friend.id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing:
        return jsonify({'error': 'Request already exists'}), 400
    
    friendship = Friendship(user_id=current_user.id, friend_id=friend.id, status='pending')
    db.session.add(friendship)
    
    notif = Notification(
        user_id=friend.id,
        type='friend_request',
        content=f"{current_user.first_name} sent you a friend request",
        from_user_id=current_user.id
    )
    db.session.add(notif)
    db.session.commit()
    
    # Emit real-time notification
    from app import socketio
    socketio.emit('new_notification', {
        'user_id': friend.id,
        'notification': {
            'id': notif.id,
            'type': notif.type,
            'content': notif.content,
            'from_user': {
                'id': current_user.id,
                'name': f"{current_user.first_name or ''} {current_user.last_name or ''}".strip() or 'User',
                'image': current_user.profile_image_url
            },
            'read': notif.read,
            'created_at': notif.created_at.isoformat()
        }
    }, room=f'user_{friend.id}')
    
    return jsonify({'success': True})

@app.route('/api/user-status/<user_id>')
@require_login
def api_user_status(user_id):
    """Get user's online status and last seen time"""
    status = get_user_status(user_id)
    return jsonify(status)

@app.route('/api/posts/<int:post_id>/comments')
@require_login
def api_get_post_comments(post_id):
    from models import Comment
    comments = Comment.query.filter_by(post_id=post_id).order_by(Comment.created_at.desc()).all()
    
    return jsonify([{
        'id': c.id,
        'content': c.content,
        'author_name': f"{c.user.first_name or ''} {c.user.last_name or ''}".strip() or 'User',
        'user_image': c.user.profile_image_url,
        'created_at': c.created_at.isoformat()
    } for c in comments])

@app.route('/api/notifications')
@require_login
def api_notifications():
    notifs = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(50).all()
    
    return jsonify([{
        'id': n.id,
        'type': n.type,
        'content': n.content,
        'from_user': {
            'id': n.from_user.id,
            'name': f"{n.from_user.first_name or ''} {n.from_user.last_name or ''}".strip() or 'User',
            'image': n.from_user.profile_image_url
        } if n.from_user else None,
        'read': n.read,
        'created_at': n.created_at.isoformat()
    } for n in notifs])

@app.route('/api/notifications/unread-count')
@require_login
def api_unread_notifications_count():
    count = Notification.query.filter_by(user_id=current_user.id, read=False).count()
    return jsonify({'count': count})

@app.route('/api/notifications/mark-all-read', methods=['POST'])
@require_login
def api_mark_all_notifications_read():
    # Mark all unread notifications as read
    Notification.query.filter_by(user_id=current_user.id, read=False).update({'read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/notifications/<int:notif_id>/respond', methods=['POST'])
@require_login
def api_respond_notification(notif_id):
    notif = Notification.query.get_or_404(notif_id)
    data = request.json
    action = data.get('action')
    
    response_data = {'success': True}
    
    if notif.type == 'friend_request':
        # Get the friendship record for this request
        friendship = Friendship.query.filter(
            ((Friendship.user_id == notif.from_user_id) & (Friendship.friend_id == current_user.id))
        ).first()
        
        if friendship:
            if action == 'accept':
                # Accept the friend request - both users follow each other
                friendship.status = 'accepted'
                
                # Update notification content to show that user started following
                requester = User.query.get(notif.from_user_id)
                if requester:
                    notif.content = f"{requester.first_name} started following you"
                
                # Create notification for the requester that they are now following back
                requester_notif = Notification(
                    user_id=notif.from_user_id,
                    type='follow_back',
                    content=f"You and {current_user.first_name} now follow each other",
                    from_user_id=current_user.id
                )
                db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'follow_back':
                # Check if there's already a pending friendship in the reverse direction
                existing_reverse_friendship = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) & 
                    (Friendship.friend_id == notif.from_user_id)
                ).first()
                
                if existing_reverse_friendship:
                    # If there's already a request, accept it to make it mutual
                    existing_reverse_friendship.status = 'accepted'
                    
                    # Update notification content for both users
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You and {requester.first_name} now follow each other"
                        
                        # Create notification for the requester
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='follow_back',
                            content=f"You and {current_user.first_name} now follow each other",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                else:
                    # User follows requester back - create a NEW pending friendship request
                    reverse_friendship = Friendship(
                        user_id=current_user.id,
                        friend_id=notif.from_user_id,
                        status='pending'
                    )
                    db.session.add(reverse_friendship)
                    
                    # Update the existing notification to show that follow back request was sent
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You requested to follow {requester.first_name}"
                        
                        # Also create a notification for the requester that they have a follow request
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='friend_request',
                            content=f"{current_user.first_name} requested to follow you",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'deny':
                # Delete/deny the friend request
                db.session.delete(friendship)
                # Also delete the notification
                db.session.delete(notif)
    
    # Mark notification as read if it still exists
    if Notification.query.get(notif_id):
        notif.read = True
        
    db.session.commit()
    return jsonify(response_data)

@app.route('/api/time-spent')
@require_login
def api_time_spent():
    from datetime import date, timedelta
    
    # Get time data for the last 365 days
    time_data = TimeSpent.query.filter_by(user_id=current_user.id).order_by(TimeSpent.date.desc()).limit(365).all()
    
    # Get today's data specifically
    today = date.today()
    today_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    # Get yesterday's data specifically
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    
    return jsonify({
        'entries': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in time_data],
        'today_minutes': today_entry.minutes if today_entry else 0,
        'yesterday_minutes': yesterday_entry.minutes if yesterday_entry else 0
    })

@app.route('/api/track-time', methods=['POST'])
@require_login
def api_track_time():
    from datetime import date, datetime, timedelta
    
    # Get today's date
    today = date.today()
    
    # Check if there's already an entry for today
    time_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    if time_entry:
        # If entry exists, increment minutes by 1
        time_entry.minutes += 1
    else:
        # If no entry exists, create a new one
        time_entry = TimeSpent(
            user_id=current_user.id,
            date=today,
            minutes=1
        )
        db.session.add(time_entry)
    
    db.session.commit()
    
    # Get total time spent today for response
    total_today = time_entry.minutes
    
    # Get yesterday's time spent
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    yesterday_minutes = yesterday_entry.minutes if yesterday_entry else 0
    
    # Also return the last 30 days of data for real-time updates
    from datetime import date, timedelta
    thirty_days_ago = today - timedelta(days=29)
    recent_time_data = TimeSpent.query.filter(
        TimeSpent.user_id == current_user.id,
        TimeSpent.date >= thirty_days_ago
    ).order_by(TimeSpent.date.asc()).all()
    
    return jsonify({
        'success': True,
        'today_minutes': total_today,
        'yesterday_minutes': yesterday_minutes,
        'recent_data': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in recent_time_data],
        'message': f'Time tracked successfully. Today: {total_today} minutes, Yesterday: {yesterday_minutes} minutes'
    })

# SocketIO Events (commented out to avoid conflicts)
@socketio.on('join')
def on_join(data):
    room = data.get('room')
    join_room(room)
    emit('user_joined', {'user': current_user.first_name}, room=room)

@socketio.on('connect')
def on_connect():
    # Join user's personal room for notifications
    from flask_socketio import join_room
    join_room(f'user_{current_user.id}')
    
    # Update user's online status
    current_user.is_online = True
    current_user.last_seen = datetime.now()
    db.session.commit()
    
@socketio.on('disconnect')
def on_disconnect():
    # Leave user's personal room
    from flask_socketio import leave_room
    leave_room(f'user_{current_user.id}')
    
    # Update user's offline status
    current_user.is_online = False
    current_user.last_seen = datetime.now()
    db.session.commit()

def get_user_status(user_id):
    """Get user's online status and last seen time"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'last_seen': None}
    
    # If user is marked as online, they are definitely online
    if user.is_online:
        return {'is_online': True, 'last_seen': user.last_seen}
    
    # If user is marked as offline but was seen recently (within 5 minutes), show as recently active
    if user.last_seen and datetime.now() - user.last_seen < timedelta(minutes=5):
        return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': True}
    
    # Otherwise, show last seen time
    return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': False}

@socketio.on('leave')
def on_leave(data):
    room = data.get('room')
    leave_room(room)
    emit('user_left', {'user': current_user.first_name}, room=room)

@socketio.on('send_message')
def on_message(data):
    room = data.get('room')
    message_text = data.get('message')
    code_snippet = data.get('code_snippet')
    receiver_id = data.get('receiver_id')
    
    message = Message(
        sender_id=current_user.id,
        receiver_id=receiver_id if receiver_id else None,
        content=message_text,
        code_snippet=code_snippet
    )
    db.session.add(message)
    db.session.commit()
    
    emit('receive_message', {
        'sender': current_user.first_name,
        'sender_image': current_user.profile_image_url,
        'message': message_text,
        'code_snippet': code_snippet,
        'timestamp': message.created_at.isoformat()
    }, room=room)

@app.route('/api/messages/<user_id>')
@require_login
def api_get_messages(user_id):
    messages = Message.query.filter(
        ((Message.sender_id == current_user.id) & (Message.receiver_id == user_id)) |
        ((Message.sender_id == user_id) & (Message.receiver_id == current_user.id))
    ).order_by(Message.created_at.asc()).all()
    
    return jsonify([{
        'id': m.id,
        'sender_id': m.sender_id,
        'content': m.content,
        'code_snippet': m.code_snippet,
        'created_at': m.created_at.isoformat()
    } for m in messages])

# App Download Route
@app.route('/download-app')
def download_app():
    try:
        # First try to serve the Windows application ZIP
        import os
        file_path = os.path.abspath('SmartFixer-Windows-App.zip')
        if os.path.exists(file_path):
            directory = os.path.dirname(file_path)
            filename = os.path.basename(file_path)
            return send_from_directory(directory, filename, as_attachment=True)
        
        # If that doesn't exist, try the distribution folder
        dist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'SmartFixer-Distribution')
        exe_path = os.path.join(dist_path, 'SmartFixer-App.exe')
        if os.path.exists(exe_path):
            return send_from_directory(dist_path, 'SmartFixer-App.exe', as_attachment=True)
        
        # Fallback if file doesn't exist
        raise FileNotFoundError("Application file not found")
    except Exception as e:
        print(f"Error in download_app: {str(e)}")
        # Return a proper error response
        return "Application download not available", 404

# QR Code generation endpoint
@app.route('/qr-code')
def qr_code():
    try:
        # Import qrcode only when needed to avoid dependency issues
        import qrcode
        from io import BytesIO
        
        # Get the download URL
        download_url = request.args.get('url', request.url_root + 'download-app')
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(download_url)
        qr.make(fit=True)
from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter


@app.route('/qr/<data>')
def qr(data):
    try:
        import qrcode
        from io import BytesIO

        # Generate QR code
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(data)
        qr.make(fit=True)

        # Create image
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Save to BytesIO
        img_io = BytesIO()
        img.save(img_io, 'PNG')
        img_io.seek(0)
        
        return send_file(img_io, mimetype='image/png')
    except ImportError:
        # Handle the case where qrcode is not installed
        return "QR Code generation not available", 404
        print("qrcode library not installed")
        return "QR Code generation not available", 404

from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/api/test-gemini', methods=['GET'])
@require_login
def api_test_gemini():
    # Updated to use the new abstraction
    from gemini_helper import test_gemini_connection
    result = test_gemini_connection()
    return jsonify({'result': result})

# Translation and Dictionary Routes
@app.route('/api/translate', methods=['POST'])
@require_login
def api_translate():
    data = request.json
    code = data.get('code', '')
    from_lang = data.get('from_lang', 'Unknown')
    to_lang = data.get('to_lang', 'Python')
    
    # Updated to use the new abstraction
    result = translate_code(code, from_lang, to_lang)
    return jsonify({'result': result})

@app.route('/api/dictionary', methods=['POST'])
@require_login
def api_dictionary():
    data = request.json
    language = data.get('language', 'Python')
    searchTerm = data.get('searchTerm', '')
    
    # Updated to use the new abstraction
    result = get_dictionary_content(language, searchTerm)
    return jsonify({'result': result})

@app.route('/api/code-history')
@require_login
def api_code_history():
    history = CodeHistory.query.filter_by(user_id=current_user.id).order_by(CodeHistory.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': h.id,
        'code': h.code,
        'language': h.language,
        'action': h.action,
        'result': h.result,
        'created_at': h.created_at.isoformat()
    } for h in history])

@app.route('/api/upload-profile-pic', methods=['POST'])
@require_login
def api_upload_profile_pic():
    try:
        if 'profile_pic' not in request.files:
            return jsonify({'error': 'No file selected'}), 400
        
        file = request.files['profile_pic']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if file and allowed_file(file.filename):
            # Ensure upload directory exists
            upload_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Generate unique filename
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            file_path = os.path.join(upload_dir, filename)
            
            # Save file
            file.save(file_path)
            
            # Update user profile
            current_user.profile_image_path = filename
            current_user.profile_image_url = f'/static/uploads/profiles/{filename}'
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'profile_image_url': current_user.profile_image_url
            })
        
        return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or GIF'}), 400
        
    except Exception as e:
        print(f"Profile upload error: {str(e)}")
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/api/update-profile', methods=['POST'])
@require_login
def api_update_profile():
    data = request.json
    username = data.get('username')
    bio = data.get('bio')
    location_enabled = data.get('location_enabled', False)
    
    # Update username if provided
    if username:
        # Check if username is already taken by another user
        existing_user = User.query.filter_by(username=username).first()
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'error': 'Username is already taken'}), 400
        current_user.username = username
    
    # Update bio if provided
    if bio is not None:
        current_user.bio = bio
    
    # Update location enabled setting
    current_user.location_enabled = location_enabled
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/posts', methods=['GET', 'POST'])
@require_login
def api_posts():
    if request.method == 'POST':
        data = request.json
        post = Post(
            user_id=current_user.id,
            code=data.get('code', ''),
            language=data.get('language', 'Unknown'),
            description=data.get('description', '')
        )
        db.session.add(post)
        db.session.commit()
        return jsonify({'success': True, 'post_id': post.id})
    
    posts = Post.query.order_by(Post.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments)
    } for p in posts])

@app.route('/api/posts/<int:post_id>/like', methods=['POST'])
@require_login
def api_like_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_like = PostLike.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_like:
        db.session.delete(existing_like)
        post.likes -= 1
    else:
        like = PostLike(post_id=post_id, user_id=current_user.id)
        db.session.add(like)
        post.likes += 1
        
        if post.user_id != current_user.id:
            # Create a more detailed notification with post preview
            post_preview = post.code[:50] + "..." if len(post.code) > 50 else post.code
            notif = Notification(
                user_id=post.user_id,
                type='like',
                content=f"{current_user.first_name} liked your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'likes': post.likes})

@app.route('/api/posts/<int:post_id>/comment', methods=['POST'])
@require_login
def api_add_comment(post_id):
    import re
    
    data = request.json
    comment_content = data.get('content', '')
    
    # Parse @username mentions and create notifications
    mentioned_usernames = re.findall(r'@(\w+)', comment_content)
    
    # Create the comment
    comment = Comment(
        post_id=post_id,
        user_id=current_user.id,
        content=comment_content
    )
    db.session.add(comment)
    
    post = Post.query.get(post_id)
    
    # Create notification for post owner (if not the commenter)
    if post and post.user_id != current_user.id:
        # Create a notification
        notif = Notification(
            user_id=post.user_id,
            type='comment',
            content=f"{current_user.first_name} commented on your post: '{comment_content}'",
            from_user_id=current_user.id
        )
        db.session.add(notif)
    
    # Create notifications for mentioned users
    for username in mentioned_usernames:
        mentioned_user = User.query.filter_by(username=username).first()
        if mentioned_user and mentioned_user.id != current_user.id and mentioned_user.id != post.user_id:
            notif = Notification(
                user_id=mentioned_user.id,
                type='mention',
                content=f"{current_user.first_name} mentioned you in a comment: '{comment_content}'",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/explore-posts')
@require_login
def api_explore_posts():
    from datetime import datetime, timedelta
    
    # Get friend IDs
    friend_ids = []
    friendships = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    for f in friendships:
        friend_id = f.friend_id if f.user_id == current_user.id else f.user_id
        friend_ids.append(friend_id)
    
    # Get posts from friends (most recent first)
    friend_posts = Post.query.filter(Post.user_id.in_(friend_ids)).order_by(Post.created_at.desc()).limit(25).all()
    
    # If we don't have enough friend posts, get posts from other users
    other_posts = []
    if len(friend_posts) < 25:
        # Get posts from other users (not friends and not self)
        other_posts = Post.query.filter(
            ~Post.user_id.in_(friend_ids + [current_user.id])
        ).order_by(Post.created_at.desc()).limit(25 - len(friend_posts)).all()
    
    # Combine posts
    all_posts = friend_posts + other_posts
    
    # Filter out any posts from users that don't exist in the system
    valid_posts = []
    for post in all_posts:
        # Verify the user exists in the system
        user = User.query.get(post.user_id)
        if user:
            valid_posts.append(post)
    
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'liked': bool(PostLike.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'saved': bool(PostSave.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments),
        'is_friend_post': p.user_id in friend_ids
    } for p in valid_posts])

@app.route('/api/share-post', methods=['POST'])
@require_login
def api_share_post():
    data = request.json
    post_id = data.get('post_id')
    friend_ids = data.get('friend_ids', [])
    
    post = Post.query.get_or_404(post_id)
    
    # Send notifications to selected friends
    for friend_id in friend_ids:
        friend = User.query.get(friend_id)
        if friend:
            notif = Notification(
                user_id=friend_id,
                type='share',
                content=f"{current_user.first_name} shared a post with you",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/friends')
@require_login
def api_friends():
    friends = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    friend_list = []
    for f in friends:
        friend_user = User.query.get(f.friend_id if f.user_id == current_user.id else f.user_id)
        if friend_user:
            friend_list.append({
                'id': friend_user.id,
                'name': f"{friend_user.first_name or ''} {friend_user.last_name or ''}".strip() or 'User',
                'image': friend_user.profile_image_url,
                'email': friend_user.email
            })
    
    return jsonify(friend_list)

@app.route('/api/friend-request', methods=['POST'])
@require_login
def api_friend_request():
    data = request.json
    friend_email = data.get('email', '')
    friend = User.query.filter_by(email=friend_email).first()
    
    if not friend:
        return jsonify({'error': 'User not found'}), 404
    
    if friend.id == current_user.id:
        return jsonify({'error': 'Cannot add yourself'}), 400
    
    existing = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == friend.id)) |
        ((Friendship.user_id == friend.id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing:
        return jsonify({'error': 'Request already exists'}), 400
    
    friendship = Friendship(user_id=current_user.id, friend_id=friend.id, status='pending')
    db.session.add(friendship)
    
    notif = Notification(
        user_id=friend.id,
        type='friend_request',
        content=f"{current_user.first_name} sent you a friend request",
        from_user_id=current_user.id
    )
    db.session.add(notif)
    db.session.commit()
    
    # Emit real-time notification
    from app import socketio
    socketio.emit('new_notification', {
        'user_id': friend.id,
        'notification': {
            'id': notif.id,
            'type': notif.type,
            'content': notif.content,
            'from_user': {
                'id': current_user.id,
                'name': f"{current_user.first_name or ''} {current_user.last_name or ''}".strip() or 'User',
                'image': current_user.profile_image_url
            },
            'read': notif.read,
            'created_at': notif.created_at.isoformat()
        }
    }, room=f'user_{friend.id}')
    
    return jsonify({'success': True})

@app.route('/api/user-status/<user_id>')
@require_login
def api_user_status(user_id):
    """Get user's online status and last seen time"""
    status = get_user_status(user_id)
    return jsonify(status)

@app.route('/api/posts/<int:post_id>/comments')
@require_login
def api_get_post_comments(post_id):
    from models import Comment
    comments = Comment.query.filter_by(post_id=post_id).order_by(Comment.created_at.desc()).all()
    
    return jsonify([{
        'id': c.id,
        'content': c.content,
        'author_name': f"{c.user.first_name or ''} {c.user.last_name or ''}".strip() or 'User',
        'user_image': c.user.profile_image_url,
        'created_at': c.created_at.isoformat()
    } for c in comments])

@app.route('/api/notifications')
@require_login
def api_notifications():
    notifs = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(50).all()
    
    return jsonify([{
        'id': n.id,
        'type': n.type,
        'content': n.content,
        'from_user': {
            'id': n.from_user.id,
            'name': f"{n.from_user.first_name or ''} {n.from_user.last_name or ''}".strip() or 'User',
            'image': n.from_user.profile_image_url
        } if n.from_user else None,
        'read': n.read,
        'created_at': n.created_at.isoformat()
    } for n in notifs])

@app.route('/api/notifications/unread-count')
@require_login
def api_unread_notifications_count():
    count = Notification.query.filter_by(user_id=current_user.id, read=False).count()
    return jsonify({'count': count})

@app.route('/api/notifications/mark-all-read', methods=['POST'])
@require_login
def api_mark_all_notifications_read():
    # Mark all unread notifications as read
    Notification.query.filter_by(user_id=current_user.id, read=False).update({'read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/notifications/<int:notif_id>/respond', methods=['POST'])
@require_login
def api_respond_notification(notif_id):
    notif = Notification.query.get_or_404(notif_id)
    data = request.json
    action = data.get('action')
    
    response_data = {'success': True}
    
    if notif.type == 'friend_request':
        # Get the friendship record for this request
        friendship = Friendship.query.filter(
            ((Friendship.user_id == notif.from_user_id) & (Friendship.friend_id == current_user.id))
        ).first()
        
        if friendship:
            if action == 'accept':
                # Accept the friend request - both users follow each other
                friendship.status = 'accepted'
                
                # Update notification content to show that user started following
                requester = User.query.get(notif.from_user_id)
                if requester:
                    notif.content = f"{requester.first_name} started following you"
                
                # Create notification for the requester that they are now following back
                requester_notif = Notification(
                    user_id=notif.from_user_id,
                    type='follow_back',
                    content=f"You and {current_user.first_name} now follow each other",
                    from_user_id=current_user.id
                )
                db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'follow_back':
                # Check if there's already a pending friendship in the reverse direction
                existing_reverse_friendship = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) & 
                    (Friendship.friend_id == notif.from_user_id)
                ).first()
                
                if existing_reverse_friendship:
                    # If there's already a request, accept it to make it mutual
                    existing_reverse_friendship.status = 'accepted'
                    
                    # Update notification content for both users
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You and {requester.first_name} now follow each other"
                        
                        # Create notification for the requester
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='follow_back',
                            content=f"You and {current_user.first_name} now follow each other",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                else:
                    # User follows requester back - create a NEW pending friendship request
                    reverse_friendship = Friendship(
                        user_id=current_user.id,
                        friend_id=notif.from_user_id,
                        status='pending'
                    )
                    db.session.add(reverse_friendship)
                    
                    # Update the existing notification to show that follow back request was sent
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You requested to follow {requester.first_name}"
                        
                        # Also create a notification for the requester that they have a follow request
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='friend_request',
                            content=f"{current_user.first_name} requested to follow you",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'deny':
                # Delete/deny the friend request
                db.session.delete(friendship)
                # Also delete the notification
                db.session.delete(notif)
    
    # Mark notification as read if it still exists
    if Notification.query.get(notif_id):
        notif.read = True
        
    db.session.commit()
    return jsonify(response_data)

@app.route('/api/time-spent')
@require_login
def api_time_spent():
    from datetime import date, timedelta
    
    # Get time data for the last 365 days
    time_data = TimeSpent.query.filter_by(user_id=current_user.id).order_by(TimeSpent.date.desc()).limit(365).all()
    
    # Get today's data specifically
    today = date.today()
    today_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    # Get yesterday's data specifically
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    
    return jsonify({
        'entries': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in time_data],
        'today_minutes': today_entry.minutes if today_entry else 0,
        'yesterday_minutes': yesterday_entry.minutes if yesterday_entry else 0
    })

@app.route('/api/track-time', methods=['POST'])
@require_login
def api_track_time():
    from datetime import date, datetime, timedelta
    
    # Get today's date
    today = date.today()
    
    # Check if there's already an entry for today
    time_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    if time_entry:
        # If entry exists, increment minutes by 1
        time_entry.minutes += 1
    else:
        # If no entry exists, create a new one
        time_entry = TimeSpent(
            user_id=current_user.id,
            date=today,
            minutes=1
        )
        db.session.add(time_entry)
    
    db.session.commit()
    
    # Get total time spent today for response
    total_today = time_entry.minutes
    
    # Get yesterday's time spent
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    yesterday_minutes = yesterday_entry.minutes if yesterday_entry else 0
    
    # Also return the last 30 days of data for real-time updates
    from datetime import date, timedelta
    thirty_days_ago = today - timedelta(days=29)
    recent_time_data = TimeSpent.query.filter(
        TimeSpent.user_id == current_user.id,
        TimeSpent.date >= thirty_days_ago
    ).order_by(TimeSpent.date.asc()).all()
    
    return jsonify({
        'success': True,
        'today_minutes': total_today,
        'yesterday_minutes': yesterday_minutes,
        'recent_data': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in recent_time_data],
        'message': f'Time tracked successfully. Today: {total_today} minutes, Yesterday: {yesterday_minutes} minutes'
    })

# SocketIO Events (commented out to avoid conflicts)
@socketio.on('join')
def on_join(data):
    room = data.get('room')
    join_room(room)
    emit('user_joined', {'user': current_user.first_name}, room=room)

# Add helper functions for user presence
def update_user_presence(user_id):
    """Update user's last active timestamp and online status"""
    user = User.query.get(user_id)
    if user:
        user.last_active = datetime.now()
        user.is_online = True
        db.session.commit()
        # Emit presence update to all connected clients
        socketio.emit('user_presence_update', {
            'user_id': user_id,
            'is_online': True,
            'last_active': user.last_active.isoformat()
        })
        return True
    return False

def get_user_presence_status(user_id):
    """Get formatted presence status for a user"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'status': 'Offline'}
    
    now = datetime.now()
    last_active = user.last_active or user.last_seen
    
    # If user is marked as online and last active within 5 minutes
    if user.is_online and (now - last_active).total_seconds() <= 300:  # 5 minutes
        return {'is_online': True, 'status': 'online'}
    
    # Calculate time difference
    diff_seconds = (now - last_active).total_seconds()
    diff_minutes = int(diff_seconds / 60)
    diff_hours = int(diff_minutes / 60)
    diff_days = (now.date() - last_active.date()).days
    
    # If less than 5 minutes ago, still show as active
    if diff_minutes < 5:
        return {'is_online': True, 'status': 'online'}
    
    # If less than 1 hour ago
    if diff_minutes < 60:
        return {
            'is_online': False, 
            'status': f'Active {diff_minutes} minute{"s" if diff_minutes != 1 else ""} ago',
            'last_seen': last_active.isoformat()
        }
    
    # Same day
    if diff_days == 0:
        return {
            'is_online': False,
            'status': f'Last seen today at {last_active.strftime("%H:%M")}',
            'last_seen': last_active.isoformat()
        }
    
    # Yesterday
    if diff_days == 1:
        return {
            'is_online': False,
            'status': f'Last seen yesterday at {last_active.strftime("%H:%M")}',
            'last_seen': last_active.isoformat()
        }
    
    # Other days
    return {
        'is_online': False,
        'status': f'Last seen on {last_active.strftime("%d/%m/%Y")} at {last_active.strftime("%H:%M")}',
        'last_seen': last_active.isoformat()
    }

# Add Socket.IO event handlers for presence tracking
@socketio.on('user_activity')
def handle_user_activity(data):
    """Handle user activity events to update presence"""
    if current_user.is_authenticated:
        update_user_presence(current_user.id)

@socketio.on('connect')
def handle_connect_presence():
    """Handle user connection to update online status"""
    if current_user.is_authenticated:
        update_user_presence(current_user.id)
        # Join user's personal room for presence notifications
        join_room(f'user_{current_user.id}')
        print(f"User {current_user.username} connected")

@socketio.on('disconnect')
def handle_disconnect_presence():
    """Handle user disconnection to update online status"""
    if current_user.is_authenticated:
        # Mark user as offline
        user = User.query.get(current_user.id)
        if user:
            user.is_online = False
            db.session.commit()
            # Emit presence update to all connected clients
            socketio.emit('user_presence_update', {
                'user_id': current_user.id,
                'is_online': False,
                'last_active': user.last_active.isoformat() if user.last_active else None
            })
        print(f"User {current_user.username} disconnected")

# Add API endpoint to get user presence status
@app.route('/api/user-presence/<user_id>')
def get_user_presence(user_id):
    """API endpoint to get user presence status"""
    if not current_user.is_authenticated:
        return jsonify({'error': 'Unauthorized'}), 401
    
    status = get_user_presence_status(user_id)
    return jsonify(status)

@socketio.on('leave')
def on_leave(data):
    room = data.get('room')
    leave_room(room)
    emit('user_left', {'user': current_user.first_name}, room=room)

@socketio.on('send_message')
def on_message(data):
    room = data.get('room')
    message_text = data.get('message')
    code_snippet = data.get('code_snippet')
    receiver_id = data.get('receiver_id')
    
    message = Message(
        sender_id=current_user.id,
        receiver_id=receiver_id if receiver_id else None,
        content=message_text,
        code_snippet=code_snippet
    )
    db.session.add(message)
    db.session.commit()
    
    emit('receive_message', {
        'sender': current_user.first_name,
        'sender_image': current_user.profile_image_url,
        'message': message_text,
        'code_snippet': code_snippet,
        'timestamp': message.created_at.isoformat()
    }, room=room)

@app.route('/api/messages/<user_id>')
@require_login
def api_get_messages(user_id):
    messages = Message.query.filter(
        ((Message.sender_id == current_user.id) & (Message.receiver_id == user_id)) |
        ((Message.sender_id == user_id) & (Message.receiver_id == current_user.id))
    ).order_by(Message.created_at.asc()).all()
    
    return jsonify([{
        'id': m.id,
        'sender_id': m.sender_id,
        'content': m.content,
        'code_snippet': m.code_snippet,
        'created_at': m.created_at.isoformat()
    } for m in messages])

# App Download Route
@app.route('/download-app')
def download_app():
    try:
        # First try to serve the Windows application ZIP
        import os
        file_path = os.path.abspath('SmartFixer-Windows-App.zip')
        if os.path.exists(file_path):
            directory = os.path.dirname(file_path)
            filename = os.path.basename(file_path)
            return send_from_directory(directory, filename, as_attachment=True)
        
        # If that doesn't exist, try the distribution folder
        dist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'SmartFixer-Distribution')
        exe_path = os.path.join(dist_path, 'SmartFixer-App.exe')
        if os.path.exists(exe_path):
            return send_from_directory(dist_path, 'SmartFixer-App.exe', as_attachment=True)
        
        # Fallback if file doesn't exist
        raise FileNotFoundError("Application file not found")
    except Exception as e:
        print(f"Error in download_app: {str(e)}")
        # Return a proper error response
        return "Application download not available", 404

# QR Code generation endpoint
@app.route('/qr-code')
def qr_code():
    try:
        # Import qrcode only when needed to avoid dependency issues
        import qrcode
        from io import BytesIO
        
        # Get the download URL
        download_url = request.args.get('url', request.url_root + 'download-app')
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(download_url)
        qr.make(fit=True)
        
        # Create image
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Save to BytesIO
        img_io = BytesIO()
        img.save(img_io, 'PNG')
        img_io.seek(0)
        
        return send_file(img_io, mimetype='image/png')
    except ImportError:
        # Handle the case where qrcode is not installed
        return "QR Code generation not available", 404



from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter
from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/api/test-gemini', methods=['GET'])
@require_login
def api_test_gemini():
    # Updated to use the new abstraction
    from gemini_helper import test_gemini_connection
    result = test_gemini_connection()
    return jsonify({'result': result})

# Translation and Dictionary Routes
@app.route('/api/translate', methods=['POST'])
@require_login
def api_translate():
    data = request.json
    code = data.get('code', '')
    from_lang = data.get('from_lang', 'Unknown')
    to_lang = data.get('to_lang', 'Python')
    
    # Updated to use the new abstraction
    result = translate_code(code, from_lang, to_lang)
    return jsonify({'result': result})

@app.route('/api/dictionary', methods=['POST'])
@require_login
def api_dictionary():
    data = request.json
    language = data.get('language', 'Python')
    searchTerm = data.get('searchTerm', '')
    
    # Updated to use the new abstraction
    result = get_dictionary_content(language, searchTerm)
    return jsonify({'result': result})

@app.route('/api/code-history')
@require_login
def api_code_history():
    history = CodeHistory.query.filter_by(user_id=current_user.id).order_by(CodeHistory.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': h.id,
        'code': h.code,
        'language': h.language,
        'action': h.action,
        'result': h.result,
        'created_at': h.created_at.isoformat()
    } for h in history])

@app.route('/api/upload-profile-pic', methods=['POST'])
@require_login
def api_upload_profile_pic():
    try:
        if 'profile_pic' not in request.files:
            return jsonify({'error': 'No file selected'}), 400
        
        file = request.files['profile_pic']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if file and allowed_file(file.filename):
            # Ensure upload directory exists
            upload_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Generate unique filename
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            file_path = os.path.join(upload_dir, filename)
            
            # Save file
            file.save(file_path)
            
            # Update user profile
            current_user.profile_image_path = filename
            current_user.profile_image_url = f'/static/uploads/profiles/{filename}'
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'profile_image_url': current_user.profile_image_url
            })
        
        return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or GIF'}), 400
        
    except Exception as e:
        print(f"Profile upload error: {str(e)}")
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/api/update-profile', methods=['POST'])
@require_login
def api_update_profile():
    data = request.json
    username = data.get('username')
    bio = data.get('bio')
    location_enabled = data.get('location_enabled', False)
    
    # Update username if provided
    if username:
        # Check if username is already taken by another user
        existing_user = User.query.filter_by(username=username).first()
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'error': 'Username is already taken'}), 400
        current_user.username = username
    
    # Update bio if provided
    if bio is not None:
        current_user.bio = bio
    
    # Update location enabled setting
    current_user.location_enabled = location_enabled
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/posts', methods=['GET', 'POST'])
@require_login
def api_posts():
    if request.method == 'POST':
        data = request.json
        post = Post(
            user_id=current_user.id,
            code=data.get('code', ''),
            language=data.get('language', 'Unknown'),
            description=data.get('description', '')
        )
        db.session.add(post)
        db.session.commit()
        return jsonify({'success': True, 'post_id': post.id})
    
    posts = Post.query.order_by(Post.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments)
    } for p in posts])

@app.route('/api/posts/<int:post_id>/like', methods=['POST'])
@require_login
def api_like_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_like = PostLike.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_like:
        db.session.delete(existing_like)
        post.likes -= 1
    else:
        like = PostLike(post_id=post_id, user_id=current_user.id)
        db.session.add(like)
        post.likes += 1
        
        if post.user_id != current_user.id:
            # Create a more detailed notification with post preview
            post_preview = post.code[:50] + "..." if len(post.code) > 50 else post.code
            notif = Notification(
                user_id=post.user_id,
                type='like',
                content=f"{current_user.first_name} liked your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'likes': post.likes})

@app.route('/api/posts/<int:post_id>/comment', methods=['POST'])
@require_login
def api_add_comment(post_id):
    import re
    
    data = request.json
    comment_content = data.get('content', '')
    
    # Parse @username mentions and create notifications
    mentioned_usernames = re.findall(r'@(\w+)', comment_content)
    
    # Create the comment
    comment = Comment(
        post_id=post_id,
        user_id=current_user.id,
        content=comment_content
    )
    db.session.add(comment)
    
    post = Post.query.get(post_id)
    
    # Create notification for post owner (if not the commenter)
    if post and post.user_id != current_user.id:
        # Create a notification
        notif = Notification(
            user_id=post.user_id,
            type='comment',
            content=f"{current_user.first_name} commented on your post: '{comment_content}'",
            from_user_id=current_user.id
        )
        db.session.add(notif)
    
    # Create notifications for mentioned users
    for username in mentioned_usernames:
        mentioned_user = User.query.filter_by(username=username).first()
        if mentioned_user and mentioned_user.id != current_user.id and mentioned_user.id != post.user_id:
            notif = Notification(
                user_id=mentioned_user.id,
                type='mention',
                content=f"{current_user.first_name} mentioned you in a comment: '{comment_content}'",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/explore-posts')
@require_login
def api_explore_posts():
    from datetime import datetime, timedelta
    
    # Get friend IDs
    friend_ids = []
    friendships = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    for f in friendships:
        friend_id = f.friend_id if f.user_id == current_user.id else f.user_id
        friend_ids.append(friend_id)
    
    # Get posts from friends (most recent first)
    friend_posts = Post.query.filter(Post.user_id.in_(friend_ids)).order_by(Post.created_at.desc()).limit(25).all()
    
    # If we don't have enough friend posts, get posts from other users
    other_posts = []
    if len(friend_posts) < 25:
        # Get posts from other users (not friends and not self)
        other_posts = Post.query.filter(
            ~Post.user_id.in_(friend_ids + [current_user.id])
        ).order_by(Post.created_at.desc()).limit(25 - len(friend_posts)).all()
    
    # Combine posts
    all_posts = friend_posts + other_posts
    
    # Filter out any posts from users that don't exist in the system
    valid_posts = []
    for post in all_posts:
        # Verify the user exists in the system
        user = User.query.get(post.user_id)
        if user:
            valid_posts.append(post)
    
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'liked': bool(PostLike.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'saved': bool(PostSave.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments),
        'is_friend_post': p.user_id in friend_ids
    } for p in valid_posts])

@app.route('/api/share-post', methods=['POST'])
@require_login
def api_share_post():
    data = request.json
    post_id = data.get('post_id')
    friend_ids = data.get('friend_ids', [])
    
    post = Post.query.get_or_404(post_id)
    
    # Send notifications to selected friends
    for friend_id in friend_ids:
        friend = User.query.get(friend_id)
        if friend:
            notif = Notification(
                user_id=friend_id,
                type='share',
                content=f"{current_user.first_name} shared a post with you",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/friends')
@require_login
def api_friends():
    friends = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    friend_list = []
    for f in friends:
        friend_user = User.query.get(f.friend_id if f.user_id == current_user.id else f.user_id)
        if friend_user:
            friend_list.append({
                'id': friend_user.id,
                'name': f"{friend_user.first_name or ''} {friend_user.last_name or ''}".strip() or 'User',
                'image': friend_user.profile_image_url,
                'email': friend_user.email
            })
    
    return jsonify(friend_list)

@app.route('/api/friend-request', methods=['POST'])
@require_login
def api_friend_request():
    data = request.json
    friend_email = data.get('email', '')
    friend = User.query.filter_by(email=friend_email).first()
    
    if not friend:
        return jsonify({'error': 'User not found'}), 404
    
    if friend.id == current_user.id:
        return jsonify({'error': 'Cannot add yourself'}), 400
    
    existing = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == friend.id)) |
        ((Friendship.user_id == friend.id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing:
        return jsonify({'error': 'Request already exists'}), 400
    
    friendship = Friendship(user_id=current_user.id, friend_id=friend.id, status='pending')
    db.session.add(friendship)
    
    notif = Notification(
        user_id=friend.id,
        type='friend_request',
        content=f"{current_user.first_name} sent you a friend request",
        from_user_id=current_user.id
    )
    db.session.add(notif)
    db.session.commit()
    
    # Emit real-time notification
    from app import socketio
    socketio.emit('new_notification', {
        'user_id': friend.id,
        'notification': {
            'id': notif.id,
            'type': notif.type,
            'content': notif.content,
            'from_user': {
                'id': current_user.id,
                'name': f"{current_user.first_name or ''} {current_user.last_name or ''}".strip() or 'User',
                'image': current_user.profile_image_url
            },
            'read': notif.read,
            'created_at': notif.created_at.isoformat()
        }
    }, room=f'user_{friend.id}')
    
    return jsonify({'success': True})

@app.route('/api/user-status/<user_id>')
@require_login
def api_user_status(user_id):
    """Get user's online status and last seen time"""
    status = get_user_status(user_id)
    return jsonify(status)

@app.route('/api/posts/<int:post_id>/comments')
@require_login
def api_get_post_comments(post_id):
    from models import Comment
    comments = Comment.query.filter_by(post_id=post_id).order_by(Comment.created_at.desc()).all()
    
    return jsonify([{
        'id': c.id,
        'content': c.content,
        'author_name': f"{c.user.first_name or ''} {c.user.last_name or ''}".strip() or 'User',
        'user_image': c.user.profile_image_url,
        'created_at': c.created_at.isoformat()
    } for c in comments])

@app.route('/api/notifications')
@require_login
def api_notifications():
    notifs = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(50).all()
    
    return jsonify([{
        'id': n.id,
        'type': n.type,
        'content': n.content,
        'from_user': {
            'id': n.from_user.id,
            'name': f"{n.from_user.first_name or ''} {n.from_user.last_name or ''}".strip() or 'User',
            'image': n.from_user.profile_image_url
        } if n.from_user else None,
        'read': n.read,
        'created_at': n.created_at.isoformat()
    } for n in notifs])

@app.route('/api/notifications/unread-count')
@require_login
def api_unread_notifications_count():
    count = Notification.query.filter_by(user_id=current_user.id, read=False).count()
    return jsonify({'count': count})

@app.route('/api/notifications/mark-all-read', methods=['POST'])
@require_login
def api_mark_all_notifications_read():
    # Mark all unread notifications as read
    Notification.query.filter_by(user_id=current_user.id, read=False).update({'read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/notifications/<int:notif_id>/respond', methods=['POST'])
@require_login
def api_respond_notification(notif_id):
    notif = Notification.query.get_or_404(notif_id)
    data = request.json
    action = data.get('action')
    
    response_data = {'success': True}
    
    if notif.type == 'friend_request':
        # Get the friendship record for this request
        friendship = Friendship.query.filter(
            ((Friendship.user_id == notif.from_user_id) & (Friendship.friend_id == current_user.id))
        ).first()
        
        if friendship:
            if action == 'accept':
                # Accept the friend request - both users follow each other
                friendship.status = 'accepted'
                
                # Update notification content to show that user started following
                requester = User.query.get(notif.from_user_id)
                if requester:
                    notif.content = f"{requester.first_name} started following you"
                
                # Create notification for the requester that they are now following back
                requester_notif = Notification(
                    user_id=notif.from_user_id,
                    type='follow_back',
                    content=f"You and {current_user.first_name} now follow each other",
                    from_user_id=current_user.id
                )
                db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'follow_back':
                # Check if there's already a pending friendship in the reverse direction
                existing_reverse_friendship = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) & 
                    (Friendship.friend_id == notif.from_user_id)
                ).first()
                
                if existing_reverse_friendship:
                    # If there's already a request, accept it to make it mutual
                    existing_reverse_friendship.status = 'accepted'
                    
                    # Update notification content for both users
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You and {requester.first_name} now follow each other"
                        
                        # Create notification for the requester
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='follow_back',
                            content=f"You and {current_user.first_name} now follow each other",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                else:
                    # User follows requester back - create a NEW pending friendship request
                    reverse_friendship = Friendship(
                        user_id=current_user.id,
                        friend_id=notif.from_user_id,
                        status='pending'
                    )
                    db.session.add(reverse_friendship)
                    
                    # Update the existing notification to show that follow back request was sent
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You requested to follow {requester.first_name}"
                        
                        # Also create a notification for the requester that they have a follow request
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='friend_request',
                            content=f"{current_user.first_name} requested to follow you",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'deny':
                # Delete/deny the friend request
                db.session.delete(friendship)
                # Also delete the notification
                db.session.delete(notif)
    
    # Mark notification as read if it still exists
    if Notification.query.get(notif_id):
        notif.read = True
        
    db.session.commit()
    return jsonify(response_data)

@app.route('/api/time-spent')
@require_login
def api_time_spent():
    from datetime import date, timedelta
    
    # Get time data for the last 365 days
    time_data = TimeSpent.query.filter_by(user_id=current_user.id).order_by(TimeSpent.date.desc()).limit(365).all()
    
    # Get today's data specifically
    today = date.today()
    today_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    # Get yesterday's data specifically
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    
    return jsonify({
        'entries': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in time_data],
        'today_minutes': today_entry.minutes if today_entry else 0,
        'yesterday_minutes': yesterday_entry.minutes if yesterday_entry else 0
    })

@app.route('/api/track-time', methods=['POST'])
@require_login
def api_track_time():
    from datetime import date, datetime, timedelta
    
    # Get today's date
    today = date.today()
    
    # Check if there's already an entry for today
    time_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    if time_entry:
        # If entry exists, increment minutes by 1
        time_entry.minutes += 1
    else:
        # If no entry exists, create a new one
        time_entry = TimeSpent(
            user_id=current_user.id,
            date=today,
            minutes=1
        )
        db.session.add(time_entry)
    
    db.session.commit()
    
    # Get total time spent today for response
    total_today = time_entry.minutes
    
    # Get yesterday's time spent
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    yesterday_minutes = yesterday_entry.minutes if yesterday_entry else 0
    
    # Also return the last 30 days of data for real-time updates
    from datetime import date, timedelta
    thirty_days_ago = today - timedelta(days=29)
    recent_time_data = TimeSpent.query.filter(
        TimeSpent.user_id == current_user.id,
        TimeSpent.date >= thirty_days_ago
    ).order_by(TimeSpent.date.asc()).all()
    
    return jsonify({
        'success': True,
        'today_minutes': total_today,
        'yesterday_minutes': yesterday_minutes,
        'recent_data': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in recent_time_data],
        'message': f'Time tracked successfully. Today: {total_today} minutes, Yesterday: {yesterday_minutes} minutes'
    })

# SocketIO Events (commented out to avoid conflicts)
@socketio.on('join')
def on_join(data):
    room = data.get('room')
    join_room(room)
    emit('user_joined', {'user': current_user.first_name}, room=room)

@socketio.on('connect')
def on_connect():
    # Join user's personal room for notifications
    from flask_socketio import join_room
    join_room(f'user_{current_user.id}')
    
    # Update user's online status
    current_user.is_online = True
    current_user.last_seen = datetime.now()
    db.session.commit()
    
@socketio.on('disconnect')
def on_disconnect():
    # Leave user's personal room
    from flask_socketio import leave_room
    leave_room(f'user_{current_user.id}')
    
    # Update user's offline status
    current_user.is_online = False
    current_user.last_seen = datetime.now()
    db.session.commit()

def get_user_status(user_id):
    """Get user's online status and last seen time"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'last_seen': None}
    
    # If user is marked as online, they are definitely online
    if user.is_online:
        return {'is_online': True, 'last_seen': user.last_seen}
    
    # If user is marked as offline but was seen recently (within 5 minutes), show as recently active
    if user.last_seen and datetime.now() - user.last_seen < timedelta(minutes=5):
        return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': True}
    
    # Otherwise, show last seen time
    return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': False}

@socketio.on('leave')
def on_leave(data):
    room = data.get('room')
    leave_room(room)
    emit('user_left', {'user': current_user.first_name}, room=room)

@socketio.on('send_message')
def on_message(data):
    room = data.get('room')
    message_text = data.get('message')
    code_snippet = data.get('code_snippet')
    receiver_id = data.get('receiver_id')
    
    message = Message(
        sender_id=current_user.id,
        receiver_id=receiver_id if receiver_id else None,
        content=message_text,
        code_snippet=code_snippet
    )
    db.session.add(message)
    db.session.commit()
    
    emit('receive_message', {
        'sender': current_user.first_name,
        'sender_image': current_user.profile_image_url,
        'message': message_text,
        'code_snippet': code_snippet,
        'timestamp': message.created_at.isoformat()
    }, room=room)

@app.route('/api/messages/<user_id>')
@require_login
def api_get_messages(user_id):
    messages = Message.query.filter(
        ((Message.sender_id == current_user.id) & (Message.receiver_id == user_id)) |
        ((Message.sender_id == user_id) & (Message.receiver_id == current_user.id))
    ).order_by(Message.created_at.asc()).all()
    
    return jsonify([{
        'id': m.id,
        'sender_id': m.sender_id,
        'content': m.content,
        'code_snippet': m.code_snippet,
        'created_at': m.created_at.isoformat()
    } for m in messages])

# App Download Route
@app.route('/download-app')
def download_app():
    try:
        # First try to serve the Windows application ZIP
        import os
        file_path = os.path.abspath('SmartFixer-Windows-App.zip')
        if os.path.exists(file_path):
            directory = os.path.dirname(file_path)
            filename = os.path.basename(file_path)
            return send_from_directory(directory, filename, as_attachment=True)
        
        # If that doesn't exist, try the distribution folder
        dist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'SmartFixer-Distribution')
        exe_path = os.path.join(dist_path, 'SmartFixer-App.exe')
        if os.path.exists(exe_path):
            return send_from_directory(dist_path, 'SmartFixer-App.exe', as_attachment=True)
        
        # Fallback if file doesn't exist
        raise FileNotFoundError("Application file not found")
    except Exception as e:
        print(f"Error in download_app: {str(e)}")
        # Return a proper error response
        return "Application download not available", 404

# QR Code generation endpoint
@app.route('/qr-code')
def qr_code():
    try:
        # Import qrcode only when needed to avoid dependency issues
        import qrcode
        from io import BytesIO
        
        # Get the download URL
        download_url = request.args.get('url', request.url_root + 'download-app')
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(download_url)
        qr.make(fit=True)
        
        # Create image
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Save to BytesIO
        img_io = BytesIO()
        img.save(img_io, 'PNG')
        img_io.seek(0)
        
        return send_file(img_io, mimetype='image/png')
    except ImportError:
        # Handle the case where qrcode is not installed
        return "QR Code generation not available", 404



from flask import session, render_template, request, jsonify, redirect, url_for, flash, current_app, send_file, send_from_directory
from flask_login import current_user, login_user, logout_user
from flask_socketio import emit, join_room, leave_room
from werkzeug.utils import secure_filename
from app import app, socketio, db
from models import *
# Import the updated gemini_helper which now uses the AI abstraction
from gemini_helper import *
from datetime import datetime, timedelta

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import HtmlFormatter
from datetime import datetime, date
from functools import wraps
import os
import re
import uuid
from werkzeug.security import generate_password_hash

# Add OCR imports
try:
    import cv2
    import numpy as np
    from PIL import Image
    import pytesseract
    import subprocess  # Add this import
    # Explicitly set the tesseract path for Windows
    if os.name == 'nt':  # Windows
        # Try common installation paths
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Tesseract-OCR\tesseract.exe'
        ]
        tesseract_found = False
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                print(f"Tesseract found at: {path}")
                break
        # If none of the above paths work, try to find it in PATH
        if not tesseract_found:
            try:
                # Try to find tesseract in PATH
                result = subprocess.run(['where', 'tesseract'], capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    tesseract_path = result.stdout.strip().split('\n')[0]
                    pytesseract.pytesseract.tesseract_cmd = tesseract_path
                    tesseract_found = True
                    print(f"Tesseract found in PATH at: {tesseract_path}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
         
        if not tesseract_found:
            # If tesseract is not found, disable OCR
            OCR_AVAILABLE = False
            print("Tesseract not found. OCR functionality will be disabled.")
        else:
            OCR_AVAILABLE = True
            print("OCR functionality enabled.")
    else:
        OCR_AVAILABLE = True
        print("OCR functionality enabled (non-Windows system).")
except ImportError as e:
    OCR_AVAILABLE = False
    print(f"OCR dependencies not installed. Image code extraction will be disabled. Error: {e}")

# OAuth imports
try:
    from authlib.integrations.flask_client import OAuth
    oauth = OAuth(app)
    
    # Google OAuth configuration - Fixed configuration
    google = oauth.register(
        name='google',
        client_id=os.getenv('GOOGLE_CLIENT_ID', 'demo-google-client-id'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET', 'demo-google-client-secret'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={
            'scope': 'openid email profile'
        }
    )
    
    # GitHub OAuth configuration
    github = oauth.register(
        name='github',
        client_id=os.getenv('GITHUB_CLIENT_ID', 'demo-github-client-id'),
        client_secret=os.getenv('GITHUB_CLIENT_SECRET', 'demo-github-client-secret'),
        access_token_url='https://github.com/login/oauth/access_token',
        authorize_url='https://github.com/login/oauth/authorize',
        api_base_url='https://api.github.com/',
        client_kwargs={'scope': 'user:email'},
    )
except ImportError:
    print("OAuth dependencies not installed. OAuth features will be disabled.")
    google = None
    github = None

# Upload folder configuration
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# Update allowed extensions to include image files and PDFs
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf', 'py', 'js', 'java', 'cpp', 'c', 'cs', 'ts', 'tsx', 'jsx', 'rb', 'php', 'swift', 'go', 'rs', 'kt', 'scala', 'pl', 'dart', 'hs', 'm', 'r', 'sql', 'sh', 'html', 'css'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def require_login(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth_page'))
        return f(*args, **kwargs)
    return decorated_function

@app.before_request
def make_session_permanent():
    session.permanent = True

# OAuth Routes
@app.route('/auth/google')
def google_login():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/google"
    
    # Store the redirect URI in session for debugging
    session['oauth_redirect_uri'] = redirect_uri
    
    return google.authorize_redirect(redirect_uri)

@app.route('/auth/github')
def github_login():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    # Get the port from command line arguments or default to 5000
    import sys
    port = 5000
    if '--port' in sys.argv:
        try:
            port_index = sys.argv.index('--port') + 1
            if port_index < len(sys.argv):
                port = int(sys.argv[port_index])
        except (ValueError, IndexError):
            pass  # Use default port 5000
    
    # Construct redirect URI with explicit port
    from flask import request
    scheme = request.scheme
    host = request.host.split(':')[0]  # Get host without port
    redirect_uri = f"{scheme}://{host}:{port}/callback/github"
    
    return github.authorize_redirect(redirect_uri)

@app.route('/callback/google')
def google_callback():
    if not google:
        flash('Google OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = google.authorize_access_token()
        user_info = token.get('userinfo')
        
        if user_info:
            # Check if user exists
            user = User.query.filter_by(email=user_info['email']).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from email prefix
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info['email'].split('@')[0].lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = user_info['email']
                user.first_name = user_info.get('given_name', '')
                user.last_name = user_info.get('family_name', '')
                user.profile_image_url = user_info.get('picture', '')
                user.oauth_provider = 'google'
                user.oauth_id = user_info['sub']
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from Google', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'Google authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/callback/github')
def github_callback():
    if not github:
        flash('GitHub OAuth not configured', 'error')
        return redirect(url_for('auth_page'))
    
    try:
        token = github.authorize_access_token()
        resp = github.get('user', token=token)
        user_info = resp.json()
        
        # Get user email
        email_resp = github.get('user/emails', token=token)
        emails = email_resp.json()
        primary_email = next((email['email'] for email in emails if email['primary']), user_info.get('email'))
        
        if user_info and primary_email:
            # Check if user exists
            user = User.query.filter_by(email=primary_email).first()
            
            is_new_user = False
            if not user:
                is_new_user = True
                # Create username from GitHub login or email
                import re
                import random
                base_username = re.sub(r'[^a-zA-Z0-9_]', '', user_info.get('login', primary_email.split('@')[0]).lower())
                
                # Ensure username is unique with random numbering
                username = base_username
                # Check if base username exists
                if User.query.filter_by(username=username).first():
                    # If base username exists, generate a random numbered version
                    while True:
                        # Generate a random number between 10 and 999
                        random_number = random.randint(10, 999)
                        username = f"{base_username}{random_number:02d}"
                        if not User.query.filter_by(username=username).first():
                            break
                
                # Create new user
                user = User()
                user.email = primary_email
                user.first_name = user_info.get('name', '').split()[0] if user_info.get('name') else ''
                user.last_name = ' '.join(user_info.get('name', '').split()[1:]) if user_info.get('name') and len(user_info.get('name', '').split()) > 1 else ''
                user.profile_image_url = user_info.get('avatar_url', '')
                user.oauth_provider = 'github'
                user.oauth_id = str(user_info['id'])
                user.username = username
                
                db.session.add(user)
                db.session.commit()
                
                print(f"✅ New user created: {user.username} ({user.email})")
            
            # Log in the user
            login_user(user, remember=True)
            print(f"✅ User logged in: {user.username} ({user.email})")
            
            # Flash a welcome message for new users
            if is_new_user:
                flash(f'Welcome to SmartFixer, {user.first_name or user.username}!', 'success')
            
            return redirect(url_for('upload_or_write'))
        else:
            flash('Failed to get user information from GitHub', 'error')
            return redirect(url_for('auth_page'))
    except Exception as e:
        import traceback
        traceback.print_exc()  # Print the full error for debugging
        flash(f'GitHub authentication failed: {str(e)}', 'error')
        return redirect(url_for('auth_page'))

@app.route('/api/test-gemini', methods=['GET'])
@require_login
def api_test_gemini():
    # Updated to use the new abstraction
    from gemini_helper import test_gemini_connection
    result = test_gemini_connection()
    return jsonify({'result': result})

# Translation and Dictionary Routes
@app.route('/api/translate', methods=['POST'])
@require_login
def api_translate():
    data = request.json
    code = data.get('code', '')
    from_lang = data.get('from_lang', 'Unknown')
    to_lang = data.get('to_lang', 'Python')
    
    # Updated to use the new abstraction
    result = translate_code(code, from_lang, to_lang)
    return jsonify({'result': result})

@app.route('/api/dictionary', methods=['POST'])
@require_login
def api_dictionary():
    data = request.json
    language = data.get('language', 'Python')
    searchTerm = data.get('searchTerm', '')
    
    # Updated to use the new abstraction
    result = get_dictionary_content(language, searchTerm)
    return jsonify({'result': result})

@app.route('/api/code-history')
@require_login
def api_code_history():
    history = CodeHistory.query.filter_by(user_id=current_user.id).order_by(CodeHistory.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': h.id,
        'code': h.code,
        'language': h.language,
        'action': h.action,
        'result': h.result,
        'created_at': h.created_at.isoformat()
    } for h in history])

@app.route('/api/upload-profile-pic', methods=['POST'])
@require_login
def api_upload_profile_pic():
    try:
        if 'profile_pic' not in request.files:
            return jsonify({'error': 'No file selected'}), 400
        
        file = request.files['profile_pic']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if file and allowed_file(file.filename):
            # Ensure upload directory exists
            upload_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'profiles')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Generate unique filename
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            file_path = os.path.join(upload_dir, filename)
            
            # Save file
            file.save(file_path)
            
            # Update user profile
            current_user.profile_image_path = filename
            current_user.profile_image_url = f'/static/uploads/profiles/{filename}'
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'profile_image_url': current_user.profile_image_url
            })
        
        return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or GIF'}), 400
        
    except Exception as e:
        print(f"Profile upload error: {str(e)}")
        return jsonify({'error': f'Upload failed: {str(e)}'}), 500

@app.route('/api/update-profile', methods=['POST'])
@require_login
def api_update_profile():
    data = request.json
    username = data.get('username')
    bio = data.get('bio')
    location_enabled = data.get('location_enabled', False)
    
    # Update username if provided
    if username:
        # Check if username is already taken by another user
        existing_user = User.query.filter_by(username=username).first()
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'error': 'Username is already taken'}), 400
        current_user.username = username
    
    # Update bio if provided
    if bio is not None:
        current_user.bio = bio
    
    # Update location enabled setting
    current_user.location_enabled = location_enabled
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/posts', methods=['GET', 'POST'])
@require_login
def api_posts():
    if request.method == 'POST':
        data = request.json
        post = Post(
            user_id=current_user.id,
            code=data.get('code', ''),
            language=data.get('language', 'Unknown'),
            description=data.get('description', '')
        )
        db.session.add(post)
        db.session.commit()
        return jsonify({'success': True, 'post_id': post.id})
    
    posts = Post.query.order_by(Post.created_at.desc()).limit(50).all()
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments)
    } for p in posts])

@app.route('/api/posts/<int:post_id>/like', methods=['POST'])
@require_login
def api_like_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_like = PostLike.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_like:
        db.session.delete(existing_like)
        post.likes -= 1
    else:
        like = PostLike(post_id=post_id, user_id=current_user.id)
        db.session.add(like)
        post.likes += 1
        
        if post.user_id != current_user.id:
            # Create a more detailed notification with post preview
            post_preview = post.code[:50] + "..." if len(post.code) > 50 else post.code
            notif = Notification(
                user_id=post.user_id,
                type='like',
                content=f"{current_user.first_name} liked your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'likes': post.likes})

@app.route('/api/posts/<int:post_id>/comment', methods=['POST'])
@require_login
def api_add_comment(post_id):
    import re
    
    data = request.json
    comment_content = data.get('content', '')
    
    # Parse @username mentions and create notifications
    mentioned_usernames = re.findall(r'@(\w+)', comment_content)
    
    # Create the comment
    comment = Comment(
        post_id=post_id,
        user_id=current_user.id,
        content=comment_content
    )
    db.session.add(comment)
    
    post = Post.query.get(post_id)
    
    # Create notification for post owner (if not the commenter)
    if post and post.user_id != current_user.id:
        # Create a notification
        notif = Notification(
            user_id=post.user_id,
            type='comment',
            content=f"{current_user.first_name} commented on your post: '{comment_content}'",
            from_user_id=current_user.id
        )
        db.session.add(notif)
    
    # Create notifications for mentioned users
    for username in mentioned_usernames:
        mentioned_user = User.query.filter_by(username=username).first()
        if mentioned_user and mentioned_user.id != current_user.id and mentioned_user.id != post.user_id:
            notif = Notification(
                user_id=mentioned_user.id,
                type='mention',
                content=f"{current_user.first_name} mentioned you in a comment: '{comment_content}'",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/explore-posts')
@require_login
def api_explore_posts():
    from datetime import datetime, timedelta
    
    # Get friend IDs
    friend_ids = []
    friendships = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    for f in friendships:
        friend_id = f.friend_id if f.user_id == current_user.id else f.user_id
        friend_ids.append(friend_id)
    
    # Get posts from friends (most recent first)
    friend_posts = Post.query.filter(Post.user_id.in_(friend_ids)).order_by(Post.created_at.desc()).limit(25).all()
    
    # If we don't have enough friend posts, get posts from other users
    other_posts = []
    if len(friend_posts) < 25:
        # Get posts from other users (not friends and not self)
        other_posts = Post.query.filter(
            ~Post.user_id.in_(friend_ids + [current_user.id])
        ).order_by(Post.created_at.desc()).limit(25 - len(friend_posts)).all()
    
    # Combine posts
    all_posts = friend_posts + other_posts
    
    # Filter out any posts from users that don't exist in the system
    valid_posts = []
    for post in all_posts:
        # Verify the user exists in the system
        user = User.query.get(post.user_id)
        if user:
            valid_posts.append(post)
    
    return jsonify([{
        'id': p.id,
        'user_id': p.user_id,
        'author_name': f"{p.author.first_name or ''} {p.author.last_name or ''}".strip() or 'User',
        'author_image': p.author.profile_image_url,
        'code': p.code,
        'language': p.language,
        'description': p.description,
        'likes': p.likes,
        'liked': bool(PostLike.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'saved': bool(PostSave.query.filter_by(post_id=p.id, user_id=current_user.id).first()),
        'created_at': p.created_at.isoformat(),
        'comments_count': len(p.comments),
        'is_friend_post': p.user_id in friend_ids
    } for p in valid_posts])

@app.route('/api/share-post', methods=['POST'])
@require_login
def api_share_post():
    data = request.json
    post_id = data.get('post_id')
    friend_ids = data.get('friend_ids', [])
    
    post = Post.query.get_or_404(post_id)
    
    # Send notifications to selected friends
    for friend_id in friend_ids:
        friend = User.query.get(friend_id)
        if friend:
            notif = Notification(
                user_id=friend_id,
                type='share',
                content=f"{current_user.first_name} shared a post with you",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/friends')
@require_login
def api_friends():
    friends = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) | (Friendship.friend_id == current_user.id)) &
        (Friendship.status == 'accepted')
    ).all()
    
    friend_list = []
    for f in friends:
        friend_user = User.query.get(f.friend_id if f.user_id == current_user.id else f.user_id)
        if friend_user:
            friend_list.append({
                'id': friend_user.id,
                'name': f"{friend_user.first_name or ''} {friend_user.last_name or ''}".strip() or 'User',
                'image': friend_user.profile_image_url,
                'email': friend_user.email
            })
    
    return jsonify(friend_list)

@app.route('/api/friend-request', methods=['POST'])
@require_login
def api_friend_request():
    data = request.json
    friend_email = data.get('email', '')
    friend = User.query.filter_by(email=friend_email).first()
    
    if not friend:
        return jsonify({'error': 'User not found'}), 404
    
    if friend.id == current_user.id:
        return jsonify({'error': 'Cannot add yourself'}), 400
    
    existing = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == friend.id)) |
        ((Friendship.user_id == friend.id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing:
        return jsonify({'error': 'Request already exists'}), 400
    
    friendship = Friendship(user_id=current_user.id, friend_id=friend.id, status='pending')
    db.session.add(friendship)
    
    notif = Notification(
        user_id=friend.id,
        type='friend_request',
        content=f"{current_user.first_name} sent you a friend request",
        from_user_id=current_user.id
    )
    db.session.add(notif)
    db.session.commit()
    
    # Emit real-time notification
    from app import socketio
    socketio.emit('new_notification', {
        'user_id': friend.id,
        'notification': {
            'id': notif.id,
            'type': notif.type,
            'content': notif.content,
            'from_user': {
                'id': current_user.id,
                'name': f"{current_user.first_name or ''} {current_user.last_name or ''}".strip() or 'User',
                'image': current_user.profile_image_url
            },
            'read': notif.read,
            'created_at': notif.created_at.isoformat()
        }
    }, room=f'user_{friend.id}')
    
    return jsonify({'success': True})

@app.route('/api/user-status/<user_id>')
@require_login
def api_user_status(user_id):
    """Get user's online status and last seen time"""
    status = get_user_status(user_id)
    return jsonify(status)

@app.route('/api/posts/<int:post_id>/comments')
@require_login
def api_get_post_comments(post_id):
    from models import Comment
    comments = Comment.query.filter_by(post_id=post_id).order_by(Comment.created_at.desc()).all()
    
    return jsonify([{
        'id': c.id,
        'content': c.content,
        'author_name': f"{c.user.first_name or ''} {c.user.last_name or ''}".strip() or 'User',
        'user_image': c.user.profile_image_url,
        'created_at': c.created_at.isoformat()
    } for c in comments])

@app.route('/api/notifications')
@require_login
def api_notifications():
    notifs = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(50).all()
    
    return jsonify([{
        'id': n.id,
        'type': n.type,
        'content': n.content,
        'from_user': {
            'id': n.from_user.id,
            'name': f"{n.from_user.first_name or ''} {n.from_user.last_name or ''}".strip() or 'User',
            'image': n.from_user.profile_image_url
        } if n.from_user else None,
        'read': n.read,
        'created_at': n.created_at.isoformat()
    } for n in notifs])

@app.route('/api/notifications/unread-count')
@require_login
def api_unread_notifications_count():
    count = Notification.query.filter_by(user_id=current_user.id, read=False).count()
    return jsonify({'count': count})

@app.route('/api/notifications/mark-all-read', methods=['POST'])
@require_login
def api_mark_all_notifications_read():
    # Mark all unread notifications as read
    Notification.query.filter_by(user_id=current_user.id, read=False).update({'read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/api/notifications/<int:notif_id>/respond', methods=['POST'])
@require_login
def api_respond_notification(notif_id):
    notif = Notification.query.get_or_404(notif_id)
    data = request.json
    action = data.get('action')
    
    response_data = {'success': True}
    
    if notif.type == 'friend_request':
        # Get the friendship record for this request
        friendship = Friendship.query.filter(
            ((Friendship.user_id == notif.from_user_id) & (Friendship.friend_id == current_user.id))
        ).first()
        
        if friendship:
            if action == 'accept':
                # Accept the friend request - both users follow each other
                friendship.status = 'accepted'
                
                # Update notification content to show that user started following
                requester = User.query.get(notif.from_user_id)
                if requester:
                    notif.content = f"{requester.first_name} started following you"
                
                # Create notification for the requester that they are now following back
                requester_notif = Notification(
                    user_id=notif.from_user_id,
                    type='follow_back',
                    content=f"You and {current_user.first_name} now follow each other",
                    from_user_id=current_user.id
                )
                db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'follow_back':
                # Check if there's already a pending friendship in the reverse direction
                existing_reverse_friendship = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) & 
                    (Friendship.friend_id == notif.from_user_id)
                ).first()
                
                if existing_reverse_friendship:
                    # If there's already a request, accept it to make it mutual
                    existing_reverse_friendship.status = 'accepted'
                    
                    # Update notification content for both users
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You and {requester.first_name} now follow each other"
                        
                        # Create notification for the requester
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='follow_back',
                            content=f"You and {current_user.first_name} now follow each other",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                else:
                    # User follows requester back - create a NEW pending friendship request
                    reverse_friendship = Friendship(
                        user_id=current_user.id,
                        friend_id=notif.from_user_id,
                        status='pending'
                    )
                    db.session.add(reverse_friendship)
                    
                    # Update the existing notification to show that follow back request was sent
                    requester = User.query.get(notif.from_user_id)
                    if requester:
                        notif.content = f"You requested to follow {requester.first_name}"
                        
                        # Also create a notification for the requester that they have a follow request
                        requester_notif = Notification(
                            user_id=notif.from_user_id,
                            type='friend_request',
                            content=f"{current_user.first_name} requested to follow you",
                            from_user_id=current_user.id
                        )
                        db.session.add(requester_notif)
                
                # Update follower counts for both users
                current_user_follower_count = Friendship.query.filter(
                    (Friendship.friend_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                current_user_following_count = Friendship.query.filter(
                    (Friendship.user_id == current_user.id) &
                    (Friendship.status == 'accepted')
                ).count()
                
                response_data['current_user_stats'] = {
                    'follower_count': current_user_follower_count,
                    'following_count': current_user_following_count
                }
                
            elif action == 'deny':
                # Delete/deny the friend request
                db.session.delete(friendship)
                # Also delete the notification
                db.session.delete(notif)
    
    # Mark notification as read if it still exists
    if Notification.query.get(notif_id):
        notif.read = True
        
    db.session.commit()
    return jsonify(response_data)

@app.route('/api/time-spent')
@require_login
def api_time_spent():
    from datetime import date, timedelta
    
    # Get time data for the last 365 days
    time_data = TimeSpent.query.filter_by(user_id=current_user.id).order_by(TimeSpent.date.desc()).limit(365).all()
    
    # Get today's data specifically
    today = date.today()
    today_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    # Get yesterday's data specifically
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    
    return jsonify({
        'entries': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in time_data],
        'today_minutes': today_entry.minutes if today_entry else 0,
        'yesterday_minutes': yesterday_entry.minutes if yesterday_entry else 0
    })

@app.route('/api/track-time', methods=['POST'])
@require_login
def api_track_time():
    from datetime import date, datetime, timedelta
    
    # Get today's date
    today = date.today()
    
    # Check if there's already an entry for today
    time_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=today).first()
    
    if time_entry:
        # If entry exists, increment minutes by 1
        time_entry.minutes += 1
    else:
        # If no entry exists, create a new one
        time_entry = TimeSpent(
            user_id=current_user.id,
            date=today,
            minutes=1
        )
        db.session.add(time_entry)
    
    db.session.commit()
    
    # Get total time spent today for response
    total_today = time_entry.minutes
    
    # Get yesterday's time spent
    yesterday = today - timedelta(days=1)
    yesterday_entry = TimeSpent.query.filter_by(user_id=current_user.id, date=yesterday).first()
    yesterday_minutes = yesterday_entry.minutes if yesterday_entry else 0
    
    # Also return the last 30 days of data for real-time updates
    from datetime import date, timedelta
    thirty_days_ago = today - timedelta(days=29)
    recent_time_data = TimeSpent.query.filter(
        TimeSpent.user_id == current_user.id,
        TimeSpent.date >= thirty_days_ago
    ).order_by(TimeSpent.date.asc()).all()
    
    return jsonify({
        'success': True,
        'today_minutes': total_today,
        'yesterday_minutes': yesterday_minutes,
        'recent_data': [{
            'date': t.date.isoformat(),
            'minutes': t.minutes
        } for t in recent_time_data],
        'message': f'Time tracked successfully. Today: {total_today} minutes, Yesterday: {yesterday_minutes} minutes'
    })

# SocketIO Events (commented out to avoid conflicts)
@socketio.on('join')
def on_join(data):
    room = data.get('room')
    join_room(room)
    emit('user_joined', {'user': current_user.first_name}, room=room)

@socketio.on('connect')
def on_connect():
    # Join user's personal room for notifications
    from flask_socketio import join_room
    join_room(f'user_{current_user.id}')
    
    # Update user's online status
    current_user.is_online = True
    current_user.last_seen = datetime.now()
    db.session.commit()
    
@socketio.on('disconnect')
def on_disconnect():
    # Leave user's personal room
    from flask_socketio import leave_room
    leave_room(f'user_{current_user.id}')
    
    # Update user's offline status
    current_user.is_online = False
    current_user.last_seen = datetime.now()
    db.session.commit()

def get_user_status(user_id):
    """Get user's online status and last seen time"""
    user = User.query.get(user_id)
    if not user:
        return {'is_online': False, 'last_seen': None}
    
    # If user is marked as online, they are definitely online
    if user.is_online:
        return {'is_online': True, 'last_seen': user.last_seen}
    
    # If user is marked as offline but was seen recently (within 5 minutes), show as recently active
    if user.last_seen and datetime.now() - user.last_seen < timedelta(minutes=5):
        return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': True}
    
    # Otherwise, show last seen time
    return {'is_online': False, 'last_seen': user.last_seen, 'recently_active': False}

@socketio.on('leave')
def on_leave(data):
    room = data.get('room')
    leave_room(room)
    emit('user_left', {'user': current_user.first_name}, room=room)

@socketio.on('send_message')
def on_message(data):
    room = data.get('room')
    message_text = data.get('message')
    code_snippet = data.get('code_snippet')
    receiver_id = data.get('receiver_id')
    
    message = Message(
        sender_id=current_user.id,
        receiver_id=receiver_id if receiver_id else None,
        content=message_text,
        code_snippet=code_snippet
    )
    db.session.add(message)
    db.session.commit()
    
    emit('receive_message', {
        'sender': current_user.first_name,
        'sender_image': current_user.profile_image_url,
        'message': message_text,
        'code_snippet': code_snippet,
        'timestamp': message.created_at.isoformat()
    }, room=room)

@app.route('/api/messages/<user_id>')
@require_login
def api_get_messages(user_id):
    messages = Message.query.filter(
        ((Message.sender_id == current_user.id) & (Message.receiver_id == user_id)) |
        ((Message.sender_id == user_id) & (Message.receiver_id == current_user.id))
    ).order_by(Message.created_at.asc()).all()
    
    return jsonify([{
        'id': m.id,
        'sender_id': m.sender_id,
        'content': m.content,
        'code_snippet': m.code_snippet,
        'created_at': m.created_at.isoformat()
    } for m in messages])

# App Download Route
@app.route('/download-app')
def download_app():
    try:
        # First try to serve the Windows application ZIP
        import os
        file_path = os.path.abspath('SmartFixer-Windows-App.zip')
        if os.path.exists(file_path):
            directory = os.path.dirname(file_path)
            filename = os.path.basename(file_path)
            return send_from_directory(directory, filename, as_attachment=True)
        
        # If that doesn't exist, try the distribution folder
        dist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'SmartFixer-Distribution')
        exe_path = os.path.join(dist_path, 'SmartFixer-App.exe')
        if os.path.exists(exe_path):
            return send_from_directory(dist_path, 'SmartFixer-App.exe', as_attachment=True)
        
        # Fallback if file doesn't exist
        raise FileNotFoundError("Application file not found")
    except Exception as e:
        print(f"Error in download_app: {str(e)}")
        # Return a proper error response
        return "Application download not available", 404

# QR Code generation endpoint
@app.route('/qr-code')
def qr_code():
    try:
        # Import qrcode only when needed to avoid dependency issues
        import qrcode
        from io import BytesIO
        
        # Get the download URL
        download_url = request.args.get('url', request.url_root + 'download-app')
        
        # Generate QR code
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(download_url)
        qr.make(fit=True)
        
        # Create image
        img = qr.make_image(fill_color="black", back_color="white")
        
        # Save to BytesIO
        img_io = BytesIO()
        img.save(img_io, 'PNG')
        img_io.seek(0)
        
        return send_file(img_io, mimetype='image/png')
    except ImportError:
        # Handle the case where qrcode is not installed
        return "QR Code generation not available", 404
        # Fallback to external service if qrcode is not installed
        return redirect(f"https://quickchart.io/qr?text={request.url_root}download-app&size=200")
    except Exception as e:
        print(f"Error generating QR code: {str(e)}")
        return "QR Code generation failed", 500

def create_simple_installer():
    """Create a simple installer file"""
    from flask import Response
    content = """#!/bin/bash
# SmartFixer Application Installer
# ==============================
# This is a simple installer script for the SmartFixer application.
# In a real implementation, this would install the complete application.

echo "SmartFixer Application Installer"
echo "================================"
echo "This would install the SmartFixer application on your system."
echo ""
echo "Installation complete!"
"""
    return Response(content, 
                   mimetype='application/octet-stream', 
                   headers={'Content-Disposition': 'attachment; filename=SmartFixer-Setup.exe'})

@app.route('/api/review', methods=['POST'])
@require_login
def api_review():
    data = request.json
    code = data.get('code', '')
    language = data.get('language', 'Unknown')
    profession = data.get('profession', 'student')
    
    try:
        # Updated to use the new abstraction
        from gemini_helper import review_code
        result = review_code(code, language, profession)
        
        # Save to history
        from models import CodeHistory
        history = CodeHistory(
            user_id=current_user.id,
            code=code,
            language=language,
            action='review',
            result=result
        )
        db.session.add(history)
        db.session.commit()
        
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': f'Failed to review code: {str(e)}'}), 500

@app.route('/api/explain', methods=['POST'])
@require_login
def api_explain():
    data = request.json
    code = data.get('code', '')
    language = data.get('language', 'Unknown')
    profession = data.get('profession', 'student')
    
    try:
        # Updated to use the new abstraction
        from gemini_helper import explain_code
        result = explain_code(code, language, profession)
        
        # Save to history
        from models import CodeHistory
        history = CodeHistory(
            user_id=current_user.id,
            code=code,
            language=language,
            action='explain',
            result=result
        )
        db.session.add(history)
        db.session.commit()
        
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': f'Failed to explain code: {str(e)}'}), 500

@app.route('/api/compile', methods=['POST'])
@require_login
def api_compile():
    data = request.json
    code = data.get('code', '')
    language = data.get('language', 'Unknown')
    profession = data.get('profession', 'student')
    
    try:
        # Updated to use the new abstraction
        from gemini_helper import compile_check
        result = compile_check(code, language, profession)
        
        # Save to history
        from models import CodeHistory
        history = CodeHistory(
            user_id=current_user.id,
            code=code,
            language=language,
            action='compile',
            result=result
        )
        db.session.add(history)
        db.session.commit()
        
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': f'Failed to compile code: {str(e)}'}), 500

@app.route('/api/question', methods=['POST'])
@require_login
def api_question():
    data = request.json
    question = data.get('question', '')
    code = data.get('code')
    language = data.get('language')
    
    try:
        # Updated to use the new abstraction
        from gemini_helper import answer_question
        result = answer_question(question, code, language)
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': f'Failed to answer question: {str(e)}'}), 500

@app.route('/api/detect-language', methods=['POST'])
@require_login
def api_detect_language():
    data = request.json
    code = data.get('code', '')
    
    try:
        # Updated to use the new abstraction
        from gemini_helper import detect_language
        language = detect_language(code)
        return jsonify({'language': language})
    except Exception as e:
        # Simple fallback language detection
        code_lower = code.lower()
        if 'def ' in code_lower and 'import ' in code_lower:
            language = 'Python'
        elif 'function ' in code_lower or 'var ' in code_lower or 'let ' in code_lower:
            language = 'JavaScript'
        elif 'public class' in code_lower or 'public static void main' in code_lower:
            language = 'Java'
        elif '#include' in code_lower or 'int main' in code_lower:
            language = 'C++'
        else:
            language = 'Unknown'
        return jsonify({'language': language})

# PWA Routes
@app.route('/manifest.json')
def manifest():
    return send_from_directory('static', 'manifest.json')

@app.route('/static/js/service-worker.js')
def service_worker():
    return send_from_directory('static/js', 'service-worker.js')

# Add OCR function to extract code from images
def extract_code_from_image(image_path):
    """Extract code from an image using OCR"""
    if not OCR_AVAILABLE:
        return None, "OCR functionality not available"
    
    try:
        # Read the image
        image = cv2.imread(image_path)
        if image is None:
            return None, "Could not read image file"
        
        # Convert to grayscale
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # Apply several preprocessing techniques to enhance text detection
        # 1. Apply Gaussian blur to reduce noise
        blurred = cv2.GaussianBlur(gray, (5, 5), 0)
        
        # 2. Apply adaptive thresholding for better contrast
        adaptive_thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)
        
        # 3. Apply morphological operations to clean up the image
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 1))
        cleaned = cv2.morphologyEx(adaptive_thresh, cv2.MORPH_CLOSE, kernel)
        
        # 4. Resize the image to improve OCR for small text
        height, width = cleaned.shape[:2]
        if height < 300 or width < 300:  # If image is small
            scale_factor = max(300/height, 300/width)
            new_width = int(width * scale_factor)
            new_height = int(height * scale_factor)
            resized = cv2.resize(cleaned, (new_width, new_height), interpolation=cv2.INTER_CUBIC)
        else:
            resized = cleaned
        
        # Use pytesseract to extract text with enhanced configuration
        custom_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!"#$%&\'()*+,-./:;<=>?@[\]^_`{|}~ '
        extracted_text = pytesseract.image_to_string(resized, config=custom_config)
        
        # Clean up the extracted text
        if extracted_text:
            # Remove extra whitespace and clean up lines
            lines = [line.strip() for line in extracted_text.split('\n') if line.strip()]
            cleaned_text = '\n'.join(lines)
            
            # Enhanced validation to check if text contains programming syntax
            if not is_programming_code(cleaned_text):
                return "", "No programming code detected in image"
            
            # Try to auto-correct syntax issues
            corrected_code = auto_correct_syntax(cleaned_text)
            
            return corrected_code, None
        else:
            return "", None
            
    except Exception as e:
        return None, f"Error processing image: {str(e)}"

def is_programming_code(text):
    """Enhanced validation to determine if text contains programming code"""
    if not text or len(text.strip()) < 10:  # Too short to be code
        return False
    
    # Look for common programming constructs
    programming_indicators = [
        # Python
        'def ', 'class ', 'import ', 'from ', 'print(', 'return',
        # JavaScript
        'function ', 'var ', 'let ', 'const ', 'console.log', '=>',
        # Java/C++
        'public ', 'private ', 'static ', 'void ', 'int ', 'String ', '#include',
        # C#
        'using ', 'namespace ', 'Console.WriteLine',
        # PHP
        '<?php', 'echo ', '$',
        # Ruby
        'puts ', 'require ',
        # Go
        'package ', 'func ',
        # Rust
        'fn ', 'let mut',
        # Shell
        '#!/bin/', 'echo ', 'if [', 'fi',
        # SQL
        'SELECT ', 'INSERT ', 'UPDATE ', 'DELETE ', 'CREATE ', 'DROP ',
        # HTML/CSS
        '<html', '<div', 'class=', 'style=', '{', '}', 'css', 'javascript',
        # XML
        '<?xml', '<![CDATA[',
        # JSON
        '{"', '"}', '["', '"]',
    ]
    
    # Check for code structure patterns
    code_patterns = [
        r'\w+\s*\([^)]*\)\s*\{',  # function() {
        r'\w+\s*\([^)]*\):',      # function():
        r'if\s*\([^)]*\)',        # if (condition)
        r'for\s*\([^)]*\)',       # for (init; condition; increment)
        r'while\s*\([^)]*\)',     # while (condition)
        r'\w+\s*=\s*[^;]*;',      # variable = value;
        r'class\s+\w+',           # class Name
        r'def\s+\w+',             # def function_name
        r'import\s+\w+',          # import module
        r'#include\s*<[^>]+>',    # #include <header>
        r'<\w+[^>]*>',            # HTML tags
        r'\.[\w-]+\s*\{',         # CSS selectors
    ]
    
    text_lower = text.lower()
    
    # Check for programming indicators
    indicator_count = sum(1 for indicator in programming_indicators if indicator in text_lower)
    
    # Check for code patterns using regex
    import re
    pattern_count = sum(1 for pattern in code_patterns if re.search(pattern, text))
    
    # Check for code elements
    code_elements = ['{', '}', '(', ')', ';', '=', '[', ']', '<', '>']
    element_count = sum(1 for element in code_elements if element in text)
    
    # Additional checks for code-like structure
    lines = text.split('\n')
    non_empty_lines = [line for line in lines if line.strip()]
    
    # Check if we have enough lines that look like code
    code_like_lines = 0
    for line in non_empty_lines:
        # Lines with semicolons, braces, or typical code patterns
        if ';' in line or '{' in line or '}' in line or re.search(r'\w+\s*\(', line) or '<' in line:
            code_like_lines += 1
    
    # Heuristic: if more than 30% of lines look like code, and we have indicators
    if len(non_empty_lines) > 0:
        code_line_ratio = code_like_lines / len(non_empty_lines)
    else:
        code_line_ratio = 0
    
    # Special handling for HTML/CSS - if it has HTML tags, it's likely code-related
    has_html_tags = '<' in text and '>' in text
    has_css_patterns = '}' in text and '{' in text
    
    # Check for explanatory text patterns that indicate this is documentation, not code
    explanatory_patterns = [
        r'\b(hello|world|example|sample|demo|test)\b',
        r'\b(write|create|make|build)\b',
        r'\b(following|below|above|next|previous)\b',
        r'\b(step|instruction|guide|tutorial)\b',
        r'\b(pretty simple|very easy|just write)\b',
        r'\b(that\'?s it|thats it)\b',
        r'\b(this is how|this is why)\b'
    ]
    
    explanatory_count = sum(1 for pattern in explanatory_patterns if re.search(pattern, text_lower))
    
    # Return True if we have sufficient evidence of programming code
    # But reject if it looks more like explanatory text than actual code
    is_code = (indicator_count >= 2 or pattern_count >= 1 or element_count >= 5) and code_line_ratio > 0.3
    
    # Special case: HTML/CSS content should be considered code
    if has_html_tags or has_css_patterns:
        is_code = True
    
    # Reject if it has too many explanatory patterns (likely documentation)
    if explanatory_count >= 3 and code_line_ratio < 0.5:
        is_code = False
    
    return is_code

def auto_correct_syntax(code):
    """Attempt to auto-correct common OCR syntax issues"""
    import re
    
    # Fix common OCR issues
    # Replace common OCR misreads
    corrections = {
        '0': 'O',  # Zero to capital O (context dependent)
        'l': 'I',  # Lowercase L to capital I (context dependent)
        'O': '0',  # Capital O to zero (context dependent)
        'I': 'l',  # Capital I to lowercase L (context dependent)
    }
    
    # For now, we'll just return the code as-is since proper auto-correction
    # would require more sophisticated analysis
    # In a production system, this would include more advanced corrections
    return code.strip()

# Add PDF function to extract code from PDFs
def extract_code_from_pdf(pdf_path):
    """Extract code from a PDF file"""
    try:
        import pdfplumber
        
        # Extract text from PDF
        extracted_text = ""
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    extracted_text += page_text + "\n"
        
        # Clean up the extracted text
        if extracted_text:
            # Remove extra whitespace and clean up lines
            lines = [line.strip() for line in extracted_text.split('\n') if line.strip()]
            cleaned_text = '\n'.join(lines)
            
            # Enhanced validation to check if text contains programming syntax
            if not is_programming_code(cleaned_text):
                return "", "No programming code detected in PDF"
            
            # Try to auto-correct syntax issues
            corrected_code = auto_correct_syntax(cleaned_text)
            
            return corrected_code, None
        else:
            return "", None
            
    except Exception as e:
        return None, f"Error processing PDF: {str(e)}"

# Add new route for extracting code from images
@app.route('/api/extract-code-from-image', methods=['POST'])
@require_login
def api_extract_code_from_image():
    try:
        if 'image' not in request.files:
            return jsonify({'success': False, 'error': 'No image file provided'}), 400
        
        file = request.files['image']
        if file.filename == '':
            return jsonify({'success': False, 'error': 'No image file selected'}), 400
        
        # Check file extension
        file_extension = file.filename.rsplit('.', 1)[1].lower()
        if file_extension not in {'png', 'jpg', 'jpeg'}:
            return jsonify({'success': False, 'error': 'Please upload an image file (PNG, JPG, JPEG).'}), 400
        
        # Create temporary directory for image processing
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'temp')
        os.makedirs(temp_dir, exist_ok=True)
        
        # Save the image temporarily
        temp_filename = str(uuid.uuid4()) + '.' + file_extension
        temp_path = os.path.join(temp_dir, temp_filename)
        file.save(temp_path)
        
        # Extract code from image
        extracted_code, error = extract_code_from_image(temp_path)
        
        # Clean up temporary file
        try:
            os.remove(temp_path)
        except:
            pass
        
        if error:
            return jsonify({'success': False, 'error': error}), 500
        
        if extracted_code is None or extracted_code.strip() == '':
            return jsonify({'success': False, 'error': 'No code detected in image'}), 200
        
        # Try to detect the programming language
        try:
            from gemini_helper import detect_language
            language = detect_language(extracted_code)
        except:
            language = "Unknown"
        
        return jsonify({
            'success': True,
            'code': extracted_code,
            'language': language
        }), 200
        
    except Exception as e:
        print(f"Error extracting code from image: {str(e)}")
        return jsonify({'success': False, 'error': f'Error processing image: {str(e)}'}), 500

@app.route('/api/extract-code-from-pdf', methods=['POST'])
@require_login
def api_extract_code_from_pdf():
    try:
        if 'pdf' not in request.files:
            return jsonify({'success': False, 'error': 'No PDF file provided'}), 400
        
        file = request.files['pdf']
        if file.filename == '':
            return jsonify({'success': False, 'error': 'No PDF file selected'}), 400
        
        # Check file extension
        file_extension = file.filename.rsplit('.', 1)[1].lower()
        if file_extension not in {'pdf'}:
            return jsonify({'success': False, 'error': 'Please upload a PDF file.'}), 400
        
        # Create temporary directory for PDF processing
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'temp')
        os.makedirs(temp_dir, exist_ok=True)
        
        # Save the PDF temporarily
        temp_filename = str(uuid.uuid4()) + '.' + file_extension
        temp_path = os.path.join(temp_dir, temp_filename)
        file.save(temp_path)
        
        # Extract code from PDF
        extracted_code, error = extract_code_from_pdf(temp_path)
        
        # Clean up temporary file
        try:
            os.remove(temp_path)
        except:
            pass
        
        if error:
            return jsonify({'success': False, 'error': error}), 500
        
        if extracted_code is None or extracted_code.strip() == '':
            return jsonify({'success': False, 'error': 'No code detected in PDF'}), 200
        
        # Try to detect the programming language
        try:
            from gemini_helper import detect_language
            language = detect_language(extracted_code)
        except:
            language = "Unknown"
        
        return jsonify({
            'success': True,
            'code': extracted_code,
            'language': language
        }), 200
        
    except Exception as e:
        print(f"Error extracting code from PDF: {str(e)}")
        return jsonify({'success': False, 'error': f'Error processing PDF: {str(e)}'}), 500

@app.route('/api/search-users', methods=['GET'])
@require_login
def api_search_users():
    query = request.args.get('q', '').strip()
    
    if not query:
        return jsonify({'users': []})
    
    # Search for users by username, first name, or last name
    users = User.query.filter(
        (User.username.ilike(f'%{query}%')) |
        (User.first_name.ilike(f'%{query}%')) |
        (User.last_name.ilike(f'%{query}%'))
    ).limit(20).all()
    
    user_list = []
    for user in users:
        # Check if there's an accepted friendship
        friendship = Friendship.query.filter(
            ((Friendship.user_id == current_user.id) & (Friendship.friend_id == user.id)) |
            ((Friendship.user_id == user.id) & (Friendship.friend_id == current_user.id))
        ).filter(Friendship.status == 'accepted').first()
        
        user_list.append({
            'id': user.id,
            'username': user.username,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'profile_image_url': user.profile_image_url,
            'is_following': friendship is not None
        })
    
    return jsonify({'users': user_list})

@app.route('/api/follow-user', methods=['POST'])
@require_login
def api_follow_user():
    data = request.json
    target_user_id = data.get('user_id')
    
    if not target_user_id:
        return jsonify({'success': False, 'error': 'User ID is required'}), 400
    
    # Check if user is trying to follow themselves
    if target_user_id == current_user.id:
        return jsonify({'success': False, 'error': 'You cannot follow yourself'}), 400
    
    target_user = User.query.get(target_user_id)
    if not target_user:
        return jsonify({'success': False, 'error': 'User not found'}), 404
    
    # Check if friendship already exists
    existing_friendship = Friendship.query.filter(
        ((Friendship.user_id == current_user.id) & (Friendship.friend_id == target_user_id)) |
        ((Friendship.user_id == target_user_id) & (Friendship.friend_id == current_user.id))
    ).first()
    
    if existing_friendship:
        if existing_friendship.status == 'accepted':
            # Already following, so unfollow
            db.session.delete(existing_friendship)
            db.session.commit()
            # Return updated counts
            follower_count = Friendship.query.filter(
                (Friendship.friend_id == current_user.id) &
                (Friendship.status == 'accepted')
            ).count()
            following_count = Friendship.query.filter(
                (Friendship.user_id == current_user.id) &
                (Friendship.status == 'accepted')
            ).count()
            return jsonify({'success': True, 'action': 'unfollowed', 'follower_count': follower_count, 'following_count': following_count})
        elif existing_friendship.status == 'pending' and existing_friendship.user_id == current_user.id:
            # Cancel pending request
            db.session.delete(existing_friendship)
            db.session.commit()
            return jsonify({'success': True, 'action': 'cancelled'})
        else:
            # Accept pending request
            existing_friendship.status = 'accepted'
            db.session.commit()
            # Return updated counts
            follower_count = Friendship.query.filter(
                (Friendship.friend_id == current_user.id) &
                (Friendship.status == 'accepted')
            ).count()
            following_count = Friendship.query.filter(
                (Friendship.user_id == current_user.id) &
                (Friendship.status == 'accepted')
            ).count()
            # Also update the target user's follower count
            target_follower_count = Friendship.query.filter(
                (Friendship.friend_id == target_user_id) &
                (Friendship.status == 'accepted')
            ).count()
            target_following_count = Friendship.query.filter(
                (Friendship.user_id == target_user_id) &
                (Friendship.status == 'accepted')
            ).count()
            return jsonify({
                'success': True, 
                'action': 'accepted', 
                'follower_count': follower_count, 
                'following_count': following_count,
                'target_follower_count': target_follower_count,
                'target_following_count': target_following_count
            })
    else:
        # Create new friendship request
        friendship = Friendship(
            user_id=current_user.id,
            friend_id=target_user_id,
            status='pending'
        )
        db.session.add(friendship)
        
        # Send notification
        notification = Notification(
            user_id=target_user_id,
            type='friend_request',
            content=f"{current_user.first_name} sent you a friend request",
            from_user_id=current_user.id
        )
        db.session.add(notification)
        
        db.session.commit()
        return jsonify({'success': True, 'action': 'requested'})

@app.route('/api/user-stats')
@require_login
def api_user_stats():
    from models import Post, Friendship
    
    # Get post count
    post_count = Post.query.filter_by(user_id=current_user.id).count()
    
    # Get follower count (users who are following current user)
    follower_count = Friendship.query.filter(
        (Friendship.friend_id == current_user.id) &
        (Friendship.status == 'accepted')
    ).count()
    
    # Get following count (users current user is following)
    following_count = Friendship.query.filter(
        (Friendship.user_id == current_user.id) &
        (Friendship.status == 'accepted')
    ).count()
    
    return jsonify({
        'post_count': post_count,
        'follower_count': follower_count,
        'following_count': following_count
    })

@app.route('/user/<user_id>')
@require_login
def user_profile(user_id):
    from models import User, Post, Friendship, TimeSpent
    from sqlalchemy import func
    
    # Get the target user
    target_user = User.query.get_or_404(user_id)
    
    # Check if this is the current user's profile
    is_current_user = (target_user.id == current_user.id)
    
    # Get friendship status if not current user
    is_following = False
    if not is_current_user:
        friendship = Friendship.query.filter(
            ((Friendship.user_id == current_user.id) & (Friendship.friend_id == target_user.id)) |
            ((Friendship.user_id == target_user.id) & (Friendship.friend_id == current_user.id))
        ).filter(Friendship.status == 'accepted').first()
        is_following = friendship is not None
    
    # Get user's posts
    posts = Post.query.filter_by(user_id=target_user.id).order_by(Post.created_at.desc()).limit(10).all()
    
    # Get user's post count
    post_count = Post.query.filter_by(user_id=target_user.id).count()
    
    # Get follower count (users who are following this user)
    follower_count = Friendship.query.filter(
        (Friendship.friend_id == target_user.id) &
        (Friendship.status == 'accepted')
    ).count()
    
    # Get following count (users this user is following)
    following_count = Friendship.query.filter(
        (Friendship.user_id == target_user.id) &
        (Friendship.status == 'accepted')
    ).count()
    
    # Get user's time spent data (last 30 days)
    time_spent_data = TimeSpent.query.filter_by(user_id=target_user.id).order_by(TimeSpent.date.desc()).limit(30).all()
    
    return render_template('user_profile.html', 
                          target_user=target_user,
                          is_current_user=is_current_user,
                          is_following=is_following,
                          posts=posts,
                          post_count=post_count,
                          follower_count=follower_count,
                          following_count=following_count,
                          time_spent_data=time_spent_data,
                          user=current_user)

@app.route('/api/user/<user_id>/followers')
@require_login
def api_user_followers(user_id):
    from models import User, Friendship
    
    user = User.query.get_or_404(user_id)
    
    # Get followers (users who are following this user)
    followers = Friendship.query.filter(
        (Friendship.friend_id == user_id) &
        (Friendship.status == 'accepted')
    ).all()
    
    follower_list = []
    for friendship in followers:
        follower = User.query.get(friendship.user_id)
        if follower:
            follower_list.append({
                'id': follower.id,
                'username': follower.username,
                'first_name': follower.first_name,
                'last_name': follower.last_name,
                'profile_image_url': follower.profile_image_url
            })
    
    return jsonify({'followers': follower_list})

@app.route('/api/user/<user_id>/following')
@require_login
def api_user_following(user_id):
    from models import User, Friendship
    
    user = User.query.get_or_404(user_id)
    
    # Get following (users this user is following)
    following = Friendship.query.filter(
        (Friendship.user_id == user_id) &
        (Friendship.status == 'accepted')
    ).all()
    
    following_list = []
    for friendship in following:
        followee = User.query.get(friendship.friend_id)
        if followee:
            following_list.append({
                'id': followee.id,
                'username': followee.username,
                'first_name': followee.first_name,
                'last_name': followee.last_name,
                'profile_image_url': followee.profile_image_url
            })
    
    return jsonify({'following': following_list})


@app.route('/api/user/<user_id>/time-spent')
@require_login
def api_user_time_spent(user_id):
    from models import User, TimeSpent
    
    user = User.query.get_or_404(user_id)
    
    # Get user's time spent data
    time_spent_data = TimeSpent.query.filter_by(user_id=user_id).order_by(TimeSpent.date.desc()).all()
    
    return jsonify({
        'entries': [{
            'date': entry.date.isoformat(),
            'minutes': entry.minutes
        } for entry in time_spent_data]
    })


@app.route('/followers')
@require_login
def followers():
    return render_template('followers.html', user=current_user, currentUserId=current_user.id)


@app.route('/following')
@require_login
def following():
    return render_template('following.html', user=current_user, currentUserId=current_user.id)


@app.route('/user/<user_id>/followers')
@require_login
def user_followers(user_id):
    target_user = User.query.get_or_404(user_id)
    return render_template('followers.html', user=current_user, currentUserId=current_user.id, target_user=target_user)


@app.route('/user/<user_id>/following')
@require_login
def user_following(user_id):
    target_user = User.query.get_or_404(user_id)
    return render_template('following.html', user=current_user, currentUserId=current_user.id, target_user=target_user)

@app.route('/api/user/<user_id>/posts')
@require_login
def api_user_posts(user_id):
    from models import Post, PostLike
    
    # Get user's posts
    posts = Post.query.filter_by(user_id=user_id).order_by(Post.created_at.desc()).all()
    
    return jsonify({
        'posts': [{
            'id': p.id,
            'likes': p.likes,
            'comments_count': len(p.comments),
            'code': p.code
        } for p in posts]
    })

@app.route('/api/user/<user_id>/saved-posts')
@require_login
def api_user_saved_posts(user_id):
    from models import Post, PostSave
    from datetime import datetime, timedelta
    
    # Get filter parameter
    filter_type = request.args.get('filter', 'all')
    
    # Get posts saved by the user
    saved_posts = PostSave.query.filter_by(user_id=user_id)
    
    # Apply filter
    if filter_type == 'week':
        one_week_ago = datetime.now() - timedelta(days=7)
        saved_posts = saved_posts.filter(PostSave.created_at >= one_week_ago)
    elif filter_type == 'oldest':
        saved_posts = saved_posts.order_by(PostSave.created_at.asc())
    else:
        saved_posts = saved_posts.order_by(PostSave.created_at.desc())
    
    saved_posts = saved_posts.all()
    post_ids = [save.post_id for save in saved_posts]
    
    # Get the actual posts
    posts = Post.query.filter(Post.id.in_(post_ids))
    
    # Apply same filter to posts
    if filter_type == 'oldest':
        posts = posts.order_by(Post.created_at.asc())
    else:
        posts = posts.order_by(Post.created_at.desc())
    
    posts = posts.all()
    
    return jsonify({
        'posts': [{
            'id': p.id,
            'likes': p.likes,
            'comments_count': len(p.comments),
            'code': p.code,
            'preview': p.code[:100] + '...' if len(p.code) > 100 else p.code
        } for p in posts]
    })

@app.route('/api/user/<user_id>/liked-posts')
@require_login
def api_user_liked_posts(user_id):
    from models import Post, PostLike
    from datetime import datetime, timedelta
    
    # Get filter parameter
    filter_type = request.args.get('filter', 'all')
    
    # Get posts liked by the user
    liked_posts = PostLike.query.filter_by(user_id=user_id)
    
    # Apply filter
    if filter_type == 'week':
        one_week_ago = datetime.now() - timedelta(days=7)
        liked_posts = liked_posts.filter(PostLike.created_at >= one_week_ago)
    elif filter_type == 'oldest':
        liked_posts = liked_posts.order_by(PostLike.created_at.asc())
    else:
        liked_posts = liked_posts.order_by(PostLike.created_at.desc())
    
    liked_posts = liked_posts.all()
    post_ids = [like.post_id for like in liked_posts]
    
    # Get the actual posts
    posts = Post.query.filter(Post.id.in_(post_ids))
    
    # Apply same filter to posts
    if filter_type == 'oldest':
        posts = posts.order_by(Post.created_at.asc())
    else:
        posts = posts.order_by(Post.created_at.desc())
    
    posts = posts.all()
    
    return jsonify({
        'posts': [{
            'id': p.id,
            'likes': p.likes,
            'comments_count': len(p.comments),
            'code': p.code
        } for p in posts]
    })


@app.route('/post/<int:post_id>')
@require_login
def view_post(post_id):
    from models import Post
    post = Post.query.get_or_404(post_id)
    return render_template('post_detail.html', post=post, user=current_user)

@app.route('/api/update-location', methods=['POST'])
@require_login
def api_update_location():
    data = request.json
    location = data.get('location')
    location_enabled = data.get('location_enabled', False)
    
    current_user.location = location
    current_user.location_enabled = location_enabled
    db.session.commit()
    
    return jsonify({'success': True})

@app.route('/api/update-location-display', methods=['POST'])
@require_login
def api_update_location_display():
    data = request.json
    location = data.get('location')
    
    current_user.location = location
    db.session.commit()
    
    return jsonify({'success': True})

@app.route('/api/posts/<int:post_id>/save', methods=['POST'])
@require_login
def api_save_post(post_id):
    post = Post.query.get_or_404(post_id)
    existing_save = PostSave.query.filter_by(post_id=post_id, user_id=current_user.id).first()
    
    if existing_save:
        db.session.delete(existing_save)
        saved = False
    else:
        save = PostSave(post_id=post_id, user_id=current_user.id)
        db.session.add(save)
        saved = True
        
        if post.user_id != current_user.id:
            notif = Notification(
                user_id=post.user_id,
                type='save',
                content=f"{current_user.first_name} saved your post",
                from_user_id=current_user.id
            )
            db.session.add(notif)
    
    db.session.commit()
    return jsonify({'success': True, 'saved': saved})


def send_system_update_notification(message):
    """Send a system update notification to all users"""
    users = User.query.all()
    
    for user in users:
        notif = Notification(
            user_id=user.id,
            type='system_update',
            content=message,
            from_user_id=None  # System notifications don't have a from user
        )
        db.session.add(notif)
    
    db.session.commit()

